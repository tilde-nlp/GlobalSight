/**
 *  Copyright 2009 Welocalize, Inc. 
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  
 *  You may obtain a copy of the License at 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */
package com.globalsight.cxe.adapter.msoffice;

//JDK
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.globalsight.cxe.adapter.AdapterResult;
import com.globalsight.cxe.adapter.IConverterHelper2;
import com.globalsight.cxe.entity.fileprofile.FileProfile;
import com.globalsight.cxe.entity.fileprofile.FileProfileImpl;
import com.globalsight.cxe.entity.filterconfiguration.FilterConstants;
import com.globalsight.cxe.entity.filterconfiguration.FilterHelper;
import com.globalsight.cxe.entity.filterconfiguration.MSOfficeExcelFilter;
import com.globalsight.cxe.entity.filterconfiguration.MSOfficePPTFilter;
import com.globalsight.cxe.message.CxeMessage;
import com.globalsight.cxe.message.CxeMessageType;
import com.globalsight.cxe.message.FileMessageData;
import com.globalsight.cxe.message.MessageDataFactory;
import com.globalsight.cxe.util.fileImport.eventFlow.Category;
import com.globalsight.cxe.util.fileImport.eventFlow.EventFlowXml;
import com.globalsight.everest.util.system.SystemConfigParamNames;
import com.globalsight.everest.util.system.SystemConfiguration;
import com.globalsight.everest.webapp.pagehandler.projects.workflows.ExportUtil;
import com.globalsight.persistence.hibernate.HibernateUtil;
import com.globalsight.util.Assert;
import com.globalsight.util.FileUtil;
import com.globalsight.util.Replacer;
import com.globalsight.util.StringUtil;
import com.globalsight.util.file.FileWaiter;

/**
 * The MicrosoftAppHelper is an abstract base class intended to be subclassed to
 * handle converting native format files (Word, Quark, Frame, etc.) to XML and
 * back.
 */
public class MicrosoftWordHelper implements IConverterHelper2
{
    //
    // CONSTANTS
    //

    /**
     * The name of the category in the event flow xml for any data specific to
     * the MicrosoftApplicationAdapter.
     */
    static public final String EFXML_DA_CATEGORY_NAME = "MicrosoftOffice";

    static private final String POST_NATIVE_TO_HTML_CONVERSION_EVENT = "HTML_IMPORTED_EVENT";
    static private final String POST_MERGE_EVENT = "MSOFFICE_LOCALIZED_EVENT";

    // For PPT issue
    // The temporary directory suffix generated by MS Office.
    static private final String TEMP_DIR_SUFFIX_2000 = "_files";
    static private final String TEMP_DIR_SUFFIX_2003 = ".files";
    private String m_tempDirSuffix = TEMP_DIR_SUFFIX_2003;
    
    private static Pattern SPAN_PATTERN = Pattern.compile("(<span[^>]*>)[\\r\\n](</span>)");

    //
    // Supported extensions for MS Office
    //

    static private final String DOC = ".doc";
    static private final String DOCX = ".docx";
    static private final String PDF = ".pdf";
    static private final String RTF = ".rtf";
    static private final String XLS = ".xls";
    static private final String XLSX = ".xlsx";
    static private final String PPT = ".ppt";
    static private final String PPTX = ".pptx";

    // The types of MS Office files (used to set m_type below).
    static private final int MS_DOC = 0;
    static private final int MS_RTF = 1;
    static private final int MS_PPT = 2;
    static private final int MS_XLS = 3;

    //
    // Private Member Data
    //
//    private String m_eventFlowXml = null;
//    protected EventFlowXmlParser m_parser = null;
    protected EventFlowXml m_eventFlowXml = null;
    private org.apache.log4j.Logger m_logger;
    private String m_safeBaseFileName = null;
    // the content specific conversion directory (D:\WINFILES\word)
    private String m_convDir = null;
    // The locale specific save directory under the conv dir.
    private String m_saveDir = null;
    private boolean m_isImport = true;

    private Properties m_msOfficeProperties = null;
    private int m_type = MS_DOC; // assume Word is the default
    // "DOC","RTF","PPT","XLS" -- goes in the command file
    private String m_conversionType = null;
    private CxeMessage m_cxeMessage = null;
    private HashMap excelStyle2Name = null;

    // Because the order of the exported pages is not reliable
    // we cannot use the pageNum information to decide if a page
    // is the last page in the Batch. So instead we keep a hashtable
    // mapping exportBatchId to pageCount.
    // As each page gets exported, we decrement the pageCount
    // When the pageCount is 0, the batch is complete
    static private Hashtable s_exportBatches = new Hashtable();

    private long fileProfileId = 0L;

    /**
     * Constructor used when adapter properties are needed.
     * 
     * @param p_cxeMessage
     *            cxeMessage
     * @param p_logger
     *            logger to use
     * @param p_msOfficeProperties
     *            - The properties of MS Office Adapter property file.
     */
    public MicrosoftWordHelper(CxeMessage p_cxeMessage,
            org.apache.log4j.Logger p_logger, Properties p_msOfficeProperties)
    {
        m_cxeMessage = p_cxeMessage;
        m_logger = p_logger;
        m_eventFlowXml = p_cxeMessage.getEventFlowObject();
        m_msOfficeProperties = p_msOfficeProperties;
    }

    //
    // Public Helper Methods
    //

    /**
     * Performs the conversion of MS Office to HTML. Returns an array of events
     * that should be published. They correspond to html import events for the
     * resulting HTML files (from the conversion).
     * 
     * @return CxeMessage[]
     * @exception MsOfficeAdapterException
     *                When conversion to HTML fails.
     */
    public synchronized AdapterResult[] performConversion()
            throws MsOfficeAdapterException
    {
        m_isImport = true;
        parseEventFlowXml();
        checkIsInstalled();

        try
        {
            String fullSafeName = writeFileToTempDir();

            m_logger.info("Converting: " + m_eventFlowXml.getDisplayName()
                    + ", size: " + m_cxeMessage.getMessageData().getSize());

            convertWithOffice();

            // Gather up the filenames.
            String expectedHtmlFileName = fullSafeName.substring(0,
                    fullSafeName.lastIndexOf(".")) + ".html";

            m_logger.debug("Expected main file is " + expectedHtmlFileName);

            File expectedHtmlFile = new File(expectedHtmlFileName);
            if (expectedHtmlFile.exists())
            {
                m_logger.debug("Expected main file exists!");
            }
            else
            {
                throw new Exception(
                        "conversion failed to produce the main HTML file: "
                                + expectedHtmlFileName);
            }

            ArrayList filesToImport = new ArrayList();

            if (m_type == MS_PPT)
            {
                // Do not import the main file. It is an empty frameset.
            }
            else
            {
                filesToImport.add(expectedHtmlFile);
            }

            // List out other HTML files in the sub dir.
            String expectedSubDirName = fullSafeName.substring(0,
                    fullSafeName.lastIndexOf("."))
                    + m_tempDirSuffix;

            File expectedSubDir = new File(expectedSubDirName);
            if (!expectedSubDir.exists())
            {
                m_tempDirSuffix = TEMP_DIR_SUFFIX_2000;
                expectedSubDirName = fullSafeName.substring(0,
                        fullSafeName.lastIndexOf("."))
                        + m_tempDirSuffix;

                expectedSubDir = new File(expectedSubDirName);
            }

            if (expectedSubDir.exists() && expectedSubDir.isDirectory())
            {
                File[] files = expectedSubDir.listFiles();
                if (m_logger.isDebugEnabled())
                {
                    m_logger.debug("Expected sub dir " + expectedSubDirName
                            + " has " + files.length + " files.");                    
                }
                // If subdir exists, the main file is a frameset,
                // we remove it.
                if (m_type == MS_XLS)
                {
                    filesToImport.remove(0);
                }

                for (int i = 0; i < files.length; i++)
                {
                    File f = files[i];
                    validateForImport(f, filesToImport);
                }

                // If there is no html files in subdir,
                // add main file again
                if (m_type == MS_XLS && filesToImport.isEmpty())
                {
                    filesToImport.add(expectedHtmlFile);
                }
            }

            // Now copy(!) all the generated files to each target
            // locale so that reconstruction is easy later.
            copyGeneratedFilesToTargetLocales(expectedSubDirName,
                    expectedHtmlFileName);

            CxeMessage[] msgs = importFiles(filesToImport);
            AdapterResult results[] = new AdapterResult[msgs.length];
            for (int i = 0; i < msgs.length; i++)
            {
                results[i] = new AdapterResult(msgs[i]);
            }

            return results;
        }
        catch (Exception ex)
        {
            m_logger.error("Could not perform conversion.", ex);
            String[] errorArgs =
            { m_eventFlowXml.getDisplayName() };
            throw new MsOfficeAdapterException("Import", errorArgs, ex);
        }
    }

    /**
     * Performs the conversion of HTML to MS Office format type. This only does
     * the conversion if the HTML file is the last page in the batch, since all
     * the pages for a MS Office file are in a job together.
     * 
     * @throws MsOfficeAdapterException
     *             - When conversion from HTML to MS Office fails.
     */
    public CxeMessage performConversionBack() throws MsOfficeAdapterException
    {
        m_isImport = false;

        parseEventFlowXml();

        try
        {
            Category c = m_eventFlowXml.getCategory("MicrosoftApplicationAdapter");
            String relSafeName = c.getValue("relSafeName");
            String saveFile = m_saveDir + File.separator + relSafeName;

            m_logger.info("ReConverting: " + m_eventFlowXml.getDisplayName()
                    + ", tmp file: " + saveFile);

            // Need to set these parameters prior to potential merge
            // errors (for gui).
            HashMap params = m_cxeMessage.getParameters();
            boolean isComp = isComponent(m_eventFlowXml.getDisplayName());

            if (isComp)
            {
                params.put("IsComponentPage", "true");
            }
            else
            {
                params.put("AbsoluteExportPath",
                        determineAbsoluteExportPathForDisplay(params));
                params.put("IsComponentPage", "false");
            }

            File saveFile_f = new File(saveFile);
            m_cxeMessage.getMessageData().copyTo(saveFile_f);

            long lastMod = saveFile_f.lastModified();
            String exportBatchId = m_eventFlowXml.getExportBatchInfo().getExportBatchId();
            String fileName = m_eventFlowXml.getSource().getValue("Filename");
            String targetLocale = m_eventFlowXml.getTargetLocale();

            // Use doc page count instead of overall batch page count.
            // int docPageCount = m_parser.getDocPageCount().intValue();
            Integer docPageCount = (Integer) params.get("DocPageCount");

            // Collect all requests for a specific multi-page document
            // under a unique key.
            String key = exportBatchId + fileName + targetLocale;

            String eBatchId = (String) params.get("ExportBatchId");
            String tFileName = (String) params.get("TargetFileName");
            if (ExportUtil.isLastFile(eBatchId, tFileName, targetLocale))
            {
                // This is the last page in the batch, so do the conversion.
                String safeBaseFileName = c.getValue("safeBaseFileName");

                String htmlName = safeBaseFileName.substring(0,
                        safeBaseFileName.lastIndexOf(".")) + ".html";
                String fullHtmlName = m_saveDir + File.separator + htmlName;
                String expectedMsoFile = m_saveDir + File.separator
                        + safeBaseFileName;

                m_logger.info("Reconstructing: " + expectedMsoFile);

                // Run the conversion process (from HTML to ppt/xls/doc).
                m_safeBaseFileName = safeBaseFileName;

                convertWithOffice();

                FileMessageData fmd = (FileMessageData) MessageDataFactory
                        .createFileMessageData();
                fmd.copyFrom(new File(expectedMsoFile));
                String originalPostMergeEvent = c.getValue("postMergeEvent");
                modifyEventFlowXmlForExport();
                CxeMessageType type = CxeMessageType
                        .getCxeMessageType(originalPostMergeEvent);
                CxeMessage outputMsg = new CxeMessage(type);
                outputMsg.setEventFlowObject(m_eventFlowXml);
                outputMsg.setMessageData(fmd);
                outputMsg.setParameters(params);

                return outputMsg;
            }
            else
            {
                // Since it was not the last page in the batch, don't
                // reconstruct the file.
                m_logger.info("Skipping reconstruction for file: " + saveFile);

                CxeMessageType type = CxeMessageType
                        .getCxeMessageType(CxeMessageType.CXE_EXPORT_STATUS_EVENT);
                CxeMessage outputMsg = new CxeMessage(type);
                outputMsg.setEventFlowObject(m_eventFlowXml);
                params.put("Exception", null);
                params.put("ExportedTime", new Long(lastMod));
                outputMsg.setParameters(params);

                return outputMsg;
            }
        }
        catch (Exception ex)
        {
            m_logger.error("Could not perform re-conversion.", ex);
            String[] errorArgs =
            { m_eventFlowXml.getDisplayName() };
            throw new MsOfficeAdapterException("Export", errorArgs, ex);
        }
    }

    //
    // Private Methods
    //

    /**
     * Copy the generated files (by MS Office) to the target locales.
     */
    private void copyGeneratedFilesToTargetLocales(String p_expectedSubDirName,
            String p_expectedHtmlFileName) throws Exception
    {
        RecursiveCopy rc = new RecursiveCopy();
        String[] targetLocales = m_eventFlowXml.getTargetLocale().split(",");
        String baseDirName = p_expectedSubDirName
                .substring(lastSeparatorIndex(p_expectedSubDirName) + 1);
        String baseFileName = p_expectedHtmlFileName
                .substring(lastSeparatorIndex(p_expectedHtmlFileName) + 1);

        File f = new File(p_expectedHtmlFileName);
        byte[] content = new byte[((int) f.length())];
        FileInputStream fis = new FileInputStream(f);
        fis.read(content);
        fis.close();

        File expectedSubDir = new File(p_expectedSubDirName);
        for (int i = 0; i < targetLocales.length; i++)
        {
            String locale = (String) targetLocales[i];
            StringBuffer targetDir = new StringBuffer(m_convDir);
            targetDir.append(File.separator);
            targetDir.append(locale);

            File targetDirF = new File(targetDir.toString());
            targetDirF.mkdirs();
            targetDir.append(File.separator);
            String targetFile = targetDir.toString() + baseFileName;
            targetDir.append(baseDirName);

            if (expectedSubDir.exists() && expectedSubDir.isDirectory())
            {
                if (m_logger.isDebugEnabled())
                {
                    m_logger.debug("Copying files from " + p_expectedSubDirName
                            + " to " + targetDir);                    
                }
                f = new File(targetDir.toString());
                boolean rv = f.mkdirs();
                m_logger.debug("Created all subdirs: " + rv);
                rc.copy(p_expectedSubDirName, targetDir.toString());
            }

            FileOutputStream fos = new FileOutputStream(targetFile);
            fos.write(content);
            fos.close();
        }
    }

    /**
     * Creates a safe file name for writing the file out to a directory where
     * other similarly named files may be. For example, someone may import
     * new_files\foo.doc and foo\foo.doc and both will be written to the same
     * directory <br>
     * 
     * @return a safe basefilename based off the display name
     */
    private String createBaseFileNameToUseForConversion()
    {
        // With so many different systems involved, the file may have
        // come from unix or NT.
        String displayName = m_eventFlowXml.getDisplayName();
        m_logger.debug("Display name is  " + displayName);

        // Find where \ and / are in the filename, and use whichever
        // is at the end.
        String baseFileName = displayName
                .substring(lastSeparatorIndex(displayName) + 1);

        // In Multi-Company, different companies may have files whose
        // displayName
        // are same, so we append timestamp at the head of the displayName to
        // distinguish them.
        // baseFileName = displayName.hashCode() + baseFileName;
        String fullPath = "";
        baseFileName = (int) (Math.random() * 1000000) + baseFileName;

        m_logger.debug("basename: " + baseFileName);

        // Make sure that the extension is lower case for conversion purposes.
        String extension = baseFileName.substring(baseFileName.length() - 3)
                .toLowerCase();
        m_logger.debug("extension: " + extension);

        if (extension.equals("pdf"))
        {
            // Replace with .doc so that Word can open up the file.
            // this is because the file has been converted to Word,
            // but the displayname still says pdf
            m_logger.debug("replacing pdf extension with doc.");
            extension = "doc";
        }

        baseFileName = baseFileName.substring(0, baseFileName.length() - 3)
                + extension;
        m_logger.debug("basename: " + baseFileName);

        fullPath = m_saveDir + File.separator + baseFileName;

        return baseFileName;
    }

    /**
     * Import the files named in the arraylist by modifying an eventflowxml for
     * each one, and then returning an array of CxeMessage objects that
     * correspond to HTML_IMPORTED_EVENTs so that the rest of CXE imports these
     * files.
     * 
     * @param filesToImport
     *            arrayList of filenames
     * @return CxeMessage[]
     * @exception Exception
     */
    private CxeMessage[] importFiles(ArrayList filesToImport) throws Exception
    {
        // For PPT issue
        HashMap slideSequence = null;
        String bulletCss = "";
        if (m_type == MS_PPT)
        {
            HashMap specialFileMap = (HashMap) filesToImport.get(0);

            slideSequence = generateSlideSequence((File) specialFileMap
                    .get("list"));
            bulletCss = generateBulletCssList((ArrayList) specialFileMap
                    .get("css"));

            filesToImport.remove(0);
        }

        Object[] x = filesToImport.toArray();
        CxeMessage[] result = new CxeMessage[x.length];
        CxeMessageType msgType = CxeMessageType
                .getCxeMessageType(CxeMessageType.HTML_IMPORTED_EVENT);

        HashMap hm = m_cxeMessage.getParameters();

        if (excelStyle2Name != null)
        {
            hm.put("excelStyleMap", excelStyle2Name);
        }

        for (int i = 0; i < x.length; i++)
        {
            File f = (File) x[i];

            if (m_logger.isDebugEnabled())
            {
                m_logger.debug("Need to import " + i + " of " + x.length + ": "
                        + f.getAbsolutePath());
            }

            EventFlowXml xml = modifyEventFlowXmlForImport(f, i + 1,
                    x.length, slideSequence, bulletCss);

            CxeMessage importMsg = new CxeMessage(msgType);
            importMsg.setEventFlowObject(xml);
            importMsg.setParameters(hm);
            FileMessageData fmd = (FileMessageData) MessageDataFactory
                    .createFileMessageData();
            fmd.copyFrom(f);
            importMsg.setMessageData(fmd);

            result[i] = importMsg;
        }

        return result;
    }

    /**
     * Modifies the EventFlowXml during export. Also restores the value of some
     * internal data based off of values saved to the EFXML. This restores the
     * EventFlowXml to (almost) the way it was before coming to the
     * MicrosoftApplication source adapter.
     */
    private void modifyEventFlowXmlForExport() throws Exception
    {
        Category c = m_eventFlowXml.getCategory("MicrosoftApplicationAdapter");
        String originalPostMergeEvent = c.getValue("postMergeEvent");
        m_eventFlowXml.setPostMergeEvent(originalPostMergeEvent);

        // Re-set the base href.
        String originalBaseHref = c.getValue("originalBaseHref");
        m_eventFlowXml.getBatchInfo().setBaseHref(originalBaseHref);
    }

    private boolean isMainFile(String fileName)
    {
        Assert.assertNotEmpty(fileName, "File name");

        String folder = fileName.substring(0, lastSeparatorIndex(fileName));
        if (folder.endsWith(TEMP_DIR_SUFFIX_2000)
                || folder.endsWith(TEMP_DIR_SUFFIX_2003))
        {
            return false;
        }

        return true;
    }

    /**
     * Modify the event flow xml for the import process.
     */
    private EventFlowXml modifyEventFlowXmlForImport(File p_htmlFile,
            int p_docPageNum, int p_docPageCount, HashMap slideSequence,
            String bulletCss) throws Exception
    {
        // First copy the EventFlowXml and then modify it.
        EventFlowXml newXml = m_eventFlowXml.clone();
        String htmlFileName = p_htmlFile.getAbsolutePath();
        // Now get all the original values and replace with new values.
        String originalPostMergeEvent = newXml.getPostMergeEvent();
        newXml.setPostMergeEvent(POST_MERGE_EVENT);
        int originalPageCount = newXml.getBatchInfo().getPageCount();
        int originalPageNumber = newXml.getBatchInfo().getPageNumber();
        newXml.getBatchInfo().setDocPageCount(p_docPageCount);
        newXml.getBatchInfo().setDocPageNumber(p_docPageNum);

        // The main Powerpoint file is not imported (see performConversion())
        // so we need to start counting at 1 for PPT.
        String newDisplayName = newXml.getDisplayName();
        if (m_type == MS_PPT)
        {
            String baseName = null;

            if (p_htmlFile.getName().indexOf("master01") == 0)
            {
                // This is master page.
                baseName = htmlFileName.substring(
                        lastSeparatorIndex(htmlFileName) + 1,
                        htmlFileName.lastIndexOf("."));
            }
            else
            {
                // This is slide page.
                StringBuffer tempBaseName = new StringBuffer("slide");

                String slideId = slideSequence.get(p_htmlFile.getName())
                        .toString();
                if (slideId.length() == 1)
                    tempBaseName.append("000");
                else if (slideId.length() == 2)
                    tempBaseName.append("00");
                else if (slideId.length() == 3)
                    tempBaseName.append("0");

                tempBaseName = tempBaseName.append(slideId);
                baseName = tempBaseName.toString();
            }

            newDisplayName = specialFormattedString(newDisplayName, baseName);
        }
        else if (m_type == MS_DOC || m_type == MS_RTF)
        {
            if (!isMainFile(htmlFileName))
            {
                String baseName = null;

                baseName = htmlFileName.substring(
                        lastSeparatorIndex(htmlFileName) + 1,
                        htmlFileName.lastIndexOf("."));

                newDisplayName = specialFormattedString(newDisplayName,
                        baseName);
            }
        }
        else if (m_type == MS_XLS)
        {
            if (p_htmlFile.getName().trim().startsWith("sheet")
                    || p_htmlFile.getName().trim().startsWith("tabstrip"))
            {
                String baseName = null;

                baseName = p_htmlFile.getName().substring(0,
                        p_htmlFile.getName().lastIndexOf("."));

                newDisplayName = specialFormattedString(newDisplayName,
                        baseName);
            }
        }

        String originalDisplayName = newXml.getDisplayName();
        newXml.getBatchInfo().setDisplayName(newDisplayName);
        String originalBaseHref = newXml.getBatchInfo().getBaseHref();
        newXml.getBatchInfo().setBaseHref(determineNewBaseHref(htmlFileName));

        // <cateogory name="MicrosoftApplicationAdapter">
        Category c = new Category();
        c.setName("MicrosoftApplicationAdapter");
        c.addValue("postMergeEvent", originalPostMergeEvent);
        c.addValue("originalPageCount", Integer.toString(originalPageCount));
        c.addValue("originalPageNumber", Integer.toString(originalPageNumber));
        c.addValue("originalDisplayName", originalDisplayName);       
        c.addValue("originalBaseHref", originalBaseHref);
        c.addValue("safeBaseFileName", m_safeBaseFileName);
        c.addValue("relSafeName", htmlFileName.substring(m_saveDir.length(),
                htmlFileName.length()));
        c.addValue("msoffice_dir", m_convDir);
        c.addValue("css_bullet", bulletCss);
        newXml.getCategory().add(c);
 
        return newXml;
    }

    /**
     * Parses the EventFlowXml to set internal values
     * 
     * @throws MsOfficeAdapterException
     */
    private void parseEventFlowXml() throws MsOfficeAdapterException
    {
        try
        {
            setType();
            setConversionDir();
            setSaveDirectory();
            setFileProfileId();
        }
        catch (Exception ex)
        {
            m_logger.error("Unable to parse EventFlowXml. ", ex);
            throw new MsOfficeAdapterException("Unexpected", null, ex);
        }
    }

    private void repairPPTX(File f) throws Exception
    {
        String content = FileUtil.readFile(f, "utf-8");
        
        content = StringUtil.replaceWithRE(content, SPAN_PATTERN, new Replacer() 
        {
			@Override
			public String getReplaceString(Matcher m) {
				return m.group(1) + "&#13;" + m.group(2);
			}
		});

        FileUtil.writeFile(f, content, "utf-8");
    }

    private void repairPPTXs(String name)
    {
        File root = new File(m_saveDir + File.separator + name
                + m_tempDirSuffix);

        if (!root.exists())
        {
            root = new File(m_saveDir + File.separator + name
                    + TEMP_DIR_SUFFIX_2000);
        }

        if (!root.exists())
        {
            return;
        }

        List<File> fs = FileUtil.getAllFiles(root, new FileFilter()
        {
            @Override
            public boolean accept(File pathname)
            {
                // TODO Auto-generated method stub
                return pathname.getName().endsWith(".html");
            }
        });

        for (File f : fs)
        {
            try
            {
                repairPPTX(f);
            }
            catch (Exception e)
            {
                m_logger.error(e.getMessage(), e);
            }
        }
    }

    /**
     * Writes out the command file to invoke the appropriate MS Office
     * converter, and waits until the conversion has completed.
     */
    private void convertWithOffice() throws Exception
    {
        String commandFileName = null;

        try
        {
            // First create the command file.
            // String baseName = m_safeBaseFileName.substring(0,
            // m_safeBaseFileName.lastIndexOf("."));
            String baseName = m_safeBaseFileName.substring(0,
                    m_safeBaseFileName.lastIndexOf("."));
            StringBuffer commandFileNameBuffer = new StringBuffer(m_saveDir);
            commandFileNameBuffer.append(File.separator).append(baseName);

            if (m_isImport)
            {
                commandFileNameBuffer.append(".im_command");
            }
            else
            {
                if ("pptx".equalsIgnoreCase(m_conversionType))
                {
                    repairPPTXs(baseName);
                }
                commandFileNameBuffer.append(".ex_command");
            }

            commandFileName = commandFileNameBuffer.toString();
            writeCommandFile(commandFileName);

            // Now wait for status file.
            StringBuffer statusFileName = new StringBuffer(m_saveDir);
            statusFileName.append(File.separator).append(baseName)
                    .append(".status");
            String maxTTW = m_msOfficeProperties
                    .getProperty(MsOfficeConfiguration.MAX_TIME_TO_WAIT);
            long maxTimeToWait = (long) (Long.parseLong(maxTTW)) * 60 * 1000;
            FileWaiter waiter = new FileWaiter(2000L, maxTimeToWait,
                    statusFileName.toString());
            waiter.waitForFile();

            // Conversion is done, but check the status to see if there is an
            // error.
            File statusFile = new File(statusFileName.toString());
            BufferedReader reader = new BufferedReader(new FileReader(
                    statusFile));
            String line = reader.readLine();
            String msg = reader.readLine();
            m_logger.info(msg);
            String errorCodeString = line.substring(6); // Error:1
            reader.close();
            statusFile.delete();
            int errorCode = Integer.parseInt(errorCodeString);
            if (errorCode > 0)
            {
                throw new Exception(msg);
            }
        }
        finally
        {
            if (commandFileName != null)
            {
                try
                {
                    File f = new File(commandFileName);
                    f.delete();
                }
                catch (Exception e)
                {
                }
            }
        }
    }

    /**
     * Actually writes out the command file. The format of the command file is:
     * ConvertFrom=doc | rtf | html | ppt | xls | docx | pptx | xlsx
     * ConvertTo=doc | rtf | html | ppt | xls | docx | pptx | xlsx
     * AcceptChanges=true | false | NA
     */
    private void writeCommandFile(String p_commandFileName) throws Exception
    {
        String convertFrom = "ConvertFrom=";
        String convertTo = "ConvertTo=";
        String acceptChanges = "AcceptChanges=";

        if (m_isImport)
        {
            convertTo += "html";
            convertFrom += m_conversionType;

            // For some reason the MsOfficeConfiguration doesn't work right.
            try
            {
                if (m_type == MS_DOC || m_type == MS_RTF)
                {
                    acceptChanges += m_msOfficeProperties
                            .getProperty(MsOfficeConfiguration.WORD_TRACKING_CHANGES);
                }
                else if (m_type == MS_XLS)
                {
                    acceptChanges += m_msOfficeProperties
                            .getProperty(MsOfficeConfiguration.EXCEL_TRACKING_CHANGES);
                }
                else
                {
                    acceptChanges += "NA";
                }
            }
            catch (Exception e)
            {
                acceptChanges += "NA";
            }
        }
        else
        {
            convertTo += m_conversionType;
            convertFrom += "html";
            acceptChanges += "NA";
        }

        StringBuffer text = new StringBuffer();
        text.append(convertFrom).append("\r\n");
        text.append(convertTo).append("\r\n");
        text.append(acceptChanges).append("\r\n");

        FileUtil.writeFileAtomically(new File(p_commandFileName),
                text.toString(), "US-ASCII");
    }

    /**
     * Returns a string in the form of "(p_str2) p_str1".
     */
    private String specialFormattedString(String p_str1, String p_str2)
    {
        StringBuffer result = new StringBuffer();

        result.append("(");
        result.append(p_str2);
        result.append(") ");
        result.append(p_str1);

        return result.toString();
    }

    /**
     * Returns a string in the form of "p_str1 (p_str2)".
     */
    private String specialJobFormattedString(String p_str1, String p_str2)
    {
        StringBuffer result = new StringBuffer();

        result.append(p_str1);
        result.append("(");
        result.append(p_str2);
        result.append(") ");

        return result.toString();
    }

    /**
     * Add the html/htm files to the list files to be imported. Just make sure
     * not to add the automatically generated error file by PowerPoint to be
     * included in the list, as it's only a generic error message that's not
     * part of the ppt file at all.
     */
    private void validateForImport(File p_file, ArrayList p_filesToImport)
    {
        String name = p_file.getAbsolutePath();
        String fileName = name.substring(name.lastIndexOf(File.separator) + 1);
        fileName = fileName.substring(0, fileName.lastIndexOf("."));

        FileProfile fileProfile = HibernateUtil.get(FileProfileImpl.class,
                Long.valueOf(fileProfileId), false);

        if (name.endsWith(".html") || name.endsWith(".htm"))
        {
            if (m_type == MS_PPT)
            {
                boolean isNotesTranslate = true;
                MSOfficePPTFilter pptFilter = null;
                try
                {
                    pptFilter = (MSOfficePPTFilter) FilterHelper.getFilter(
                            FilterConstants.MSOFFICEPPT_TABLENAME,
                            fileProfile.getFilterId());
                    isNotesTranslate = pptFilter.isNotesTranslate();
                }
                catch (Exception e)
                {
                    m_logger.warn("Failed to load PPT filter, validateForImport().");
                }
                // Only import slide page and master01 page.
                // The master01 page covers comments in each slide.
                // Determine master is to be translated or not.
                String isMasterTranslate = SystemConfiguration.getInstance()
                        .getStringParameter(
                                SystemConfigParamNames.PPT_MASTER_TRANSLATE);

                if (fileName.indexOf("slide") == 0)
                {
                    p_filesToImport.add(p_file);
                }
                else if ("master01".equalsIgnoreCase(fileName)
                        && (Boolean.parseBoolean(isMasterTranslate) || isNotesTranslate))
                {
                    p_filesToImport.add(p_file);
                }
            }
            else if (m_type == MS_XLS)
            {
                boolean isTabNamesTranslate = false;
                MSOfficeExcelFilter excelFilter = null;
                try
                {
                    excelFilter = (MSOfficeExcelFilter) FilterHelper.getFilter(
                            FilterConstants.MSOFFICEEXCEL_TABLENAME,
                            fileProfile.getFilterId());
                    isTabNamesTranslate = excelFilter.isTabNamesTranslate();
                }
                catch (Exception e)
                {
                    m_logger.warn("Failed to load EXCEL filter, validateForImport().");
                }
                if ("tabstrip".equalsIgnoreCase(fileName)
                        && !isTabNamesTranslate)
                {
                    // for GBS-2416, do not extract tab names
                    return;
                }
                p_filesToImport.add(p_file);
            }
            else
            {
                // GBS-789 : Can not create aligner package with MS Office file
                // formats
                // There is no fileProfileId when create Aligner Package, and we
                // assign it as 0.
                if ("header".equalsIgnoreCase(fileName) && m_type == MS_DOC
                        && fileProfileId != 0)
                {
                    if (fileProfile.translateHeader())
                    {
                        p_filesToImport.add(p_file);
                    }
                }
                else
                {
                    p_filesToImport.add(p_file);
                }
            }
        }
        else if (name.endsWith(".xml"))
        {
            if ((m_type == MS_PPT) && "filelist".equalsIgnoreCase(fileName))
            {
                // The first place in array list was holding by an empty string.
                // We need to put the filelist.xml in the first place.
                // We need to get the slide sequence from the filelist file.
                // After get the sequence, the filelist.xml will be removed.
                HashMap specialFileMap = null;

                if ((p_filesToImport == null) || (p_filesToImport.size() < 1)
                        || (p_filesToImport.get(0) instanceof File))
                {
                    specialFileMap = new HashMap();
                    specialFileMap.put("list", p_file);
                    p_filesToImport.add(0, specialFileMap);
                }
                else if (p_filesToImport.get(0) instanceof HashMap)
                {
                    specialFileMap = (HashMap) p_filesToImport.get(0);
                    specialFileMap.put("list", p_file);
                    p_filesToImport.set(0, specialFileMap);
                }
            }
        }
        else if (name.endsWith(".css"))
        {
            if (m_type == MS_PPT)
            {
                HashMap specialFileMap = null;

                boolean hasFileMap = false;
                if ((p_filesToImport == null) || (p_filesToImport.size() < 1)
                        || (p_filesToImport.get(0) instanceof File))
                {
                    specialFileMap = new HashMap();
                }
                else if (p_filesToImport.get(0) instanceof HashMap)
                {
                    specialFileMap = (HashMap) p_filesToImport.get(0);
                    hasFileMap = true;
                }

                ArrayList cssFileList = null;
                if (specialFileMap.get("css") == null)
                {
                    cssFileList = new ArrayList();
                }
                else
                {
                    cssFileList = (ArrayList) specialFileMap.get("css");
                }

                cssFileList.add(p_file);
                specialFileMap.put("css", cssFileList);

                if (hasFileMap)
                {
                    p_filesToImport.set(0, specialFileMap);
                }
                else
                {
                    p_filesToImport.add(0, specialFileMap);
                }
            }
            // For Excel DO NOT TRANSLATE parameter, this parameter
            // is configed into css style, we fetch them here and later
            // load them into one Map to be transformed as one parameter
            // in JMS to html extraction
            else if (m_type == MS_XLS)
            {
                excelStyle2Name = new HashMap();
                HashMap tempMap = new HashMap();
                FileReader fr = null;
                BufferedReader br = null;
                try
                {
                    fr = new FileReader(p_file);
                    br = new BufferedReader(fr);
                    String style = "";
                    String styleName = "";
                    String line = br.readLine();
                    while (line != null)
                    {
                        if (line.startsWith(".style"))
                        {
                            // Entered one style definition
                            style = line;
                            line = br.readLine();
                            while (!(line.startsWith(".style"))
                                    && (line.indexOf("mso-style-name") == -1))
                            {
                                // Keep looping until entered next style
                                // definiton
                                // or found style name.
                                line = br.readLine();
                                continue;
                            }
                            if (line.startsWith(".style"))
                            {
                                // Entered the next style definition
                                continue;
                            }
                            else if ((line.indexOf("mso-style-name") != -1))
                            {
                                // Found style name.
                                int beginIndex = line.indexOf("mso-style-name")
                                        + "mso-style-name:".length();
                                int endIndex = line.indexOf(";", beginIndex);
                                styleName = line
                                        .substring(beginIndex, endIndex);
                                // Map style to name in tem Map.
                                tempMap.put(style.substring(1), styleName);
                            }
                        }

                        if (line.startsWith(".x"))
                        {
                            // Entered class (html class element)definition
                            style = line;
                            line = br.readLine();

                            while (!(line.startsWith(".x"))
                                    && (line.indexOf("mso-style-parent") == -1))
                            {
                                // Keep looping until entered next class (html
                                // class element)
                                // definiton or found style parent.
                                line = br.readLine();
                                continue;
                            }

                            if (line.startsWith(".x"))
                            {
                                // Entered the next class (html class definiton)
                                // definition.
                                continue;
                            }
                            else if ((line.indexOf("mso-style-parent") != -1))
                            {
                                // found style parent.
                                int beginIndex = line
                                        .indexOf("mso-style-parent")
                                        + "mso-style-parent:".length();
                                int endIndex = line.indexOf(";", beginIndex);
                                styleName = (String) tempMap.get(line
                                        .substring(beginIndex, endIndex));
                                // Map class (html class element) to style
                                // parent name.
                                excelStyle2Name.put(style.substring(1),
                                        styleName);
                            }
                        }
                        line = br.readLine();
                    }
                    br.close();
                    fr.close();
                }
                catch (Exception e)
                {
                    m_logger.info("Excel Style fetching failed");
                }
                finally
                {
                    if (br != null)
                    {
                        try
                        {
                            br.close();
                        }
                        catch (Exception e)
                        {
                            // Do nothing.
                        }
                    }
                    if (fr != null)
                    {
                        try
                        {
                            fr.close();
                        }
                        catch (Exception e)
                        {
                            // Do nothing.
                        }
                    }
                }

            }
        }
    }

    /**
     * For PPT issue Get the slide sequence from filelist.xml
     */
    private HashMap generateSlideSequence(File p_file) throws Exception
    {
        String SLIDE_PATTERN = "<o:File HRef=\"slide\\d+\\.html?\"/>";
        Pattern pattern = Pattern.compile(SLIDE_PATTERN);

        HashMap slideSequence = new HashMap();
        int sequence = 0;

        BufferedReader reader = new BufferedReader(new FileReader(p_file));
        String line = null;
        while ((line = reader.readLine()) != null)
        {
            if (pattern.matcher(line).find())
            {
                slideSequence.put(
                        line.substring(line.indexOf("slide"),
                                line.lastIndexOf("\"")),
                        new Integer(++sequence));
            }
        }

        return slideSequence;
    }

    /**
     * For PPT issue Get the bullet style from css files
     */
    private String generateBulletCssList(ArrayList cssFiles) throws Exception
    {
        StringBuffer bulletCss = new StringBuffer();

        String BULLET_CSS_PATTERN = "\\.(\\w+)\\s*\\{(mso-special-format:\\w*bullet)";
        Pattern pattern = Pattern.compile(BULLET_CSS_PATTERN);

        for (int i = 0; i < cssFiles.size(); i++)
        {
            StringBuffer cssFileContent = new StringBuffer();

            BufferedReader reader = new BufferedReader(new FileReader(
                    (File) cssFiles.get(i)));
            String line = null;
            while ((line = reader.readLine()) != null)
            {
                cssFileContent = cssFileContent.append(line);
            }

            Matcher matcher = pattern.matcher(cssFileContent);
            while (matcher.find())
            {
                bulletCss = bulletCss.append(matcher.group(1).trim());
                // Use / as the separator
                bulletCss = bulletCss.append("/");
            }
        }

        return bulletCss.toString();
    }

    /**
     * Write the MS Office file to a temporary directory for future reference.
     */
    private String writeFileToTempDir() throws Exception
    {
        m_safeBaseFileName = createBaseFileNameToUseForConversion();
        String fullSafeName = m_saveDir + File.separator + m_safeBaseFileName;

        m_logger.debug("Writing MS Office file to: " + fullSafeName);

        File file = new File(fullSafeName);
        m_cxeMessage.getMessageData().copyTo(file);

        return fullSafeName;
    }

    /**
     * Returns the event to publish after doing a conversion from Native to XML. <br>
     * 
     * @return something like "GlobalSight::XmlImportedEvent"
     */
    public String getPostNativeToXmlConversionEvent()
    {
        return POST_NATIVE_TO_HTML_CONVERSION_EVENT;
    }

    private void setFileProfileId()
    {
        // GBS-789 : Can not create aligner package with MS Office file formats
        // There is no fileProfileId when create Aligner Package, and we assign
        // it as 0.
        String fpId = m_eventFlowXml.getBatchInfo().getFileProfileId();
        if (fpId == null || fpId.equalsIgnoreCase("null"))
        {
            fileProfileId = 0;
        }
        else
        {
            fileProfileId = Long.parseLong(fpId);
        }
    }

    /**
     * Sets the internal type (MS_DOC,MS_RTF,etc.)
     */
    private void setType()
    {
        String name = m_eventFlowXml.getDisplayName().toLowerCase();

        if (name.endsWith(DOC) || name.endsWith(PDF))
        {
            m_type = MS_DOC;
            m_conversionType = "doc";
        }
        else if (name.endsWith(RTF))
        {
            m_type = MS_RTF;
            m_conversionType = "rtf";
        }
        else if (name.endsWith(PPT))
        {
            m_type = MS_PPT;
            m_conversionType = "ppt";
        }
        else if (name.endsWith(XLS))
        {
            m_type = MS_XLS;
            m_conversionType = "xls";
        }
        else if (name.endsWith(DOCX))
        {
            m_type = MS_DOC;
            m_conversionType = "docx";
        }
        else if (name.endsWith(PPTX))
        {
            m_type = MS_PPT;
            m_conversionType = "pptx";
        }
        else if (name.endsWith(XLSX))
        {
            m_type = MS_XLS;
            m_conversionType = "xlsx";
        }
    }

    /**
     * Determines and sets the content specific conversion directory, for
     * example: D:\WINFILES\word
     */
    private void setConversionDir() throws Exception
    {
        StringBuffer convDir = new StringBuffer(SystemConfiguration
                .getInstance().getStringParameter(
                        SystemConfigParamNames.MSOFFICE_CONV_DIR));

        String formatName = m_eventFlowXml.getSource().getFormatName().toLowerCase();
        if (formatName != null
                && ("word2003".equals(formatName)
                        || "excel2003".equals(formatName) || "powerpoint2003"
                            .equals(formatName)))
        {
            convDir = new StringBuffer(SystemConfiguration.getInstance()
                    .getStringParameter(
                            SystemConfigParamNames.MSOFFICE2003_CONV_DIR));
        }

        convDir.append(File.separator);

        if (m_type == MS_DOC || m_type == MS_RTF)
        {
            convDir.append("word");
        }
        else if (m_type == MS_PPT)
        {
            convDir.append("powerpoint");
        }
        else if (m_type == MS_XLS)
        {
            convDir.append("excel");
        }

        m_convDir = convDir.toString();
    }

    /**
     * Determines and sets the locale specific save directory during
     * import/export process.
     */
    private void setSaveDirectory() throws Exception
    {
        // First save the file out to a temp location.
        StringBuffer saveDir = new StringBuffer(m_convDir);

        saveDir.append(File.separator);
        saveDir.append(m_isImport ? m_eventFlowXml.getSourceLocale() : m_eventFlowXml
                .getTargetLocale());
        File saveDirF = new File(saveDir.toString());
        saveDirF.mkdirs();

        m_saveDir = saveDir.toString();
    }

    /**
     * Helps in finding the last separator in the string. If the name contains
     * both / and \ then it returns the greatest index value.
     */
    private int lastSeparatorIndex(String p_name)
    {
        int forwardSlashIndex = p_name.lastIndexOf('\\');
        int backwardSlashIndex = p_name.lastIndexOf('/');
        int lastSeparatorindex = (forwardSlashIndex > backwardSlashIndex) ? forwardSlashIndex
                : backwardSlashIndex;
        return lastSeparatorindex;
    }

    /**
     * Figures out a temporary base href to use that points to the temp area.
     * The baseHref will look something like: http://blah:7001/word/en_US
     */
    private String determineNewBaseHref(String p_htmlFileName) throws Exception
    {
        String convDir = SystemConfiguration.getInstance().getStringParameter(
                SystemConfigParamNames.MSOFFICE_CONV_DIR);
        String formatName = m_eventFlowXml.getSource().getFormatName().toLowerCase();
        if (formatName != null
                && ("word2003".equals(formatName)
                        || "excel2003".equals(formatName) || "powerpoint2003"
                            .equals(formatName)))
        {
            convDir = SystemConfiguration.getInstance().getStringParameter(
                    SystemConfigParamNames.MSOFFICE2003_CONV_DIR);
        }
        String capLoginUrl = SystemConfiguration.getInstance()
                .getStringParameter(SystemConfigParamNames.CAP_LOGIN_URL);
        StringBuffer newBaseHref = new StringBuffer();
        newBaseHref.append(capLoginUrl.substring(0,
                capLoginUrl.lastIndexOf("/")));
        newBaseHref.append("/");

        if (m_type == MS_PPT)
        {
            // PPT needs the filename_files directory in the basehref
            // because the URLs to the imgs are just the image filename.
            String relPath = p_htmlFileName.substring(convDir.length() + 1,
                    lastSeparatorIndex(p_htmlFileName));

            if (relPath.indexOf(m_tempDirSuffix) > -1)
            {
                newBaseHref.append(relPath);
            }
            else
            {
                String s = p_htmlFileName.substring(convDir.length() + 1,
                        p_htmlFileName.lastIndexOf("."));
                newBaseHref.append(s);
                newBaseHref.append(m_tempDirSuffix);
            }
        }
        else
        {
            // Word and Excel only need the main convdir because the
            // imgs contain better relative URLs.
            int idx = p_htmlFileName.lastIndexOf(m_tempDirSuffix);
            String relPath = p_htmlFileName.substring(convDir.length() + 1,
                    lastSeparatorIndex(p_htmlFileName));
            if (idx > -1)
            {
                newBaseHref.append(relPath.substring(0,
                        lastSeparatorIndex(relPath)));
            }
            else
            {
                newBaseHref.append(relPath);
            }
        }

        String rv = newBaseHref.toString().replace('\\', '/');

        m_logger.debug("new basehref is now: " + rv);

        return rv;
    }

    /**
     * Figures out what the user friendly Absolute Export Path would be.
     */
    private String determineAbsoluteExportPathForDisplay(HashMap p_params)
    {
        String displayName = m_eventFlowXml.getDisplayName();
        String exportLocation = (String) p_params.get("ExportLocation");
        String localeSubDir = (String) p_params.get("LocaleSubDir");

        // Take the filename minus the leading directory name.
        int separatorIndex = displayName.indexOf(File.separator);
        String truncatedFilename = displayName.substring(separatorIndex + 1);

        StringBuffer fullpath = new StringBuffer(exportLocation);
        fullpath.append(localeSubDir).append(File.separator);
        fullpath.append(truncatedFilename);

        return fullpath.toString();
    }

    /**
     * Figures out if this is a component file.
     * 
     * @return boolean "true" if it is a component otherwise "false"
     */
    private boolean isComponent(String p_name)
    {
        if (m_logger.isDebugEnabled())
        {
            m_logger.debug("isComponent=" + p_name.startsWith("(")
                    + ", pageName=" + p_name);
        }

        return p_name.startsWith("(");
    }

    private void checkIsInstalled() throws MsOfficeAdapterException
    {
        if ((m_type == MS_DOC || m_type == MS_RTF)
                && !MsOfficeAdapter.isWordInstalled())
        {
            throw new MsOfficeAdapterException("WordNotInstalled", null, null);
        }

        if (m_type == MS_XLS && !MsOfficeAdapter.isExcelInstalled())
        {
            throw new MsOfficeAdapterException("ExcelNotInstalled", null, null);
        }

        if (m_type == MS_PPT && !MsOfficeAdapter.isPowerPointInstalled())
        {
            throw new MsOfficeAdapterException("PowerPointNotInstalled", null,
                    null);
        }
    }
}
