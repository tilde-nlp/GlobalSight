// -*- Mode: Java -*-
/*
 * Copyright (c) 2000 GlobalSight Corporation. All rights reserved.
 *
 * THIS DOCUMENT CONTAINS TRADE SECRET DATA WHICH IS THE PROPERTY OF
 * GLOBALSIGHT CORPORATION. THIS DOCUMENT IS SUBMITTED TO RECIPIENT
 * IN CONFIDENCE. INFORMATION CONTAINED HEREIN MAY NOT BE USED, COPIED
 * OR DISCLOSED IN WHOLE OR IN PART EXCEPT AS PERMITTED BY WRITTEN
 * AGREEMENT SIGNED BY AN OFFICER OF GLOBALSIGHT CORPORATION.
 *
 * THIS MATERIAL IS ALSO COPYRIGHTED AS AN UNPUBLISHED WORK UNDER
 * SECTIONS 104 AND 408 OF TITLE 17 OF THE UNITED STATES CODE.
 * UNAUTHORIZED USE, COPYING OR OTHER REPRODUCTION IS PROHIBITED
 * BY LAW.
 */

/*
 * ColdFusion Script Grammar - copied from javascript.jj.
 * Not yet complete. Wed Mar 28 03:11:40 2001.
 */

options {
  STATIC = false;
  LOOKAHEAD = 1;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  IGNORE_CASE = true;
  DEBUG_PARSER = false;
}


PARSER_BEGIN(Parser)
package com.globalsight.ling.docproc.extractor.cfscript;

/**
 * A CFScript Parser automatically generated by JavaCC.  Fires {@link
 * com.globalsight.ling.docproc.extractor.cfscript.IParseEvents
 * IParseEvents}.
 */
public class Parser
{
    private IParseEvents m_handler = null;

    public void setHandler(IParseEvents handler)
    {
        m_handler = handler;
    }

    private void appendToken(Token t1, String s, Token t2)
    {
        t1.image = t1.image + ((s != null) ? s : "") + t2.image;
        t1.endLine = t2.endLine;
        t1.endColumn = t2.endColumn;
        t1.next = t2.next;
    }

}
PARSER_END(Parser)


TOKEN : /* WHITE SPACE - \u001a = ^Z \u00a0 = nbsp*/
{
  <S: (" " | "\t" | "\f" | "\u001a" | "\u00a0")+ >
|
  <L: ("\n" | "\r" | "\r\n")+ >
|
  <UNICODE_BOM: ("\uFEFF"|"\uFFFE") >
}

TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT:
    "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
|
  /* This one can only occur immediately before EOF */
  <CRIPPLED_SINGLE_LINE_COMMENT:
    "//" (~["\n","\r"])* ( <CDC> (~["\n","\r"])* )? >
|
  <MULTI_LINE_COMMENT:
    "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

/*
 * Sun Nov 03 16:24:20 2002 CvdL: not sure if scripts can contain real
 * CF comments, which can be recursive. See gs_html.jj for how to
 * recognize them.
 */
TOKEN : /* CFScript SEPARATORS */
{
  <CDO: "<!---" ("-")* >
|
  <CDC: "---" ("-")* ">" >
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DELETE: "delete" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FUNCTION: "function" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < IN: "in" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRY: "try" >
| < TYPEOF: "typeof" >      // CvdL: this is both a function and operator
| < VAR: "var">
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < WITH: "with" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ (<EXPONENT>)?
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
        ( "\"" ( (~["\""])+ | "\"" "\"" (~["\""])* )* "\"" )
      | ( "'"  ( (~["'"] )+ | "'"  "'"  (~["'"] )* )* "'"  )
  >
|
  < #ESCAPE_SEQUENCE:
      "\\"
        ( ["n","t","b","r","f","\\","'","\""]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        | "x" ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
        | "u" ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
              ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
          // NONESCAPECHARACTER - any other single char
        | (~["n","t","b","r","f","\\","'","\"","u","x","0"-"9","\n","\r"])
        )
  >
|
  < BOOLEAN_LITERAL:
        "true"
      |
        "false"
  >
|
  < NULL_LITERAL:
      "null"
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < HASH: "#" >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < DOT: "." >

// Comparison operators
| < IS: "IS">
| < EQ: "EQ" >
| < EQUAL: "EQUAL" >
| < IS_NOT: "IS" (<S>|<L>)+ "NOT" >
| < NOT_EQUAL: "NOT" (<S>|<L>)+ "EQUAL" >
| < NEQ: "NEQ" >
| < CONTAINS: "CONTAINS">
| < DOES_NOT_CONTAIN: "DOES" (<S>|<L>)+ "NOT" (<S>|<L>)+ "CONTAIN">
| < GREATER_THAN: "GREATER" (<S>|<L>)+ "THAN" >
| < GT: "GT" >
| < LESS_THAN:    "LESS" (<S>|<L>)+ "THAN" >
| < LT: "LT" >
| < GREATER_THAN_OR_EQ_TO: "GREATER" (<S>|<L>)+ "THAN" (<S>|<L>)+
              "OR" (<S>|<L>)+ "EQUAL" (<S>|<L>)+ "TO">
| < GTE: "GTE" >
| < GE:  "GE" >
| < LESS_THAN_OR_EQ_TO:    "LESS" (<S>|<L>)+ "THAN" (<S>|<L>)+
              "OR" (<S>|<L>)+ "EQUAL" (<S>|<L>)+ "TO">
| < LTE: "LTE" >
| < LE:  "LE" >

// Boolean and logical operators
| < OR:  "OR" >
| < XOR: "XOR" >
| < AND: "AND" >
| < NOT: "NOT" >
| < EQV: "EQV" >
| < IMP: "IMP" >

// Arithmetic operatirs
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < CONCAT: "&" >                                 // String concatenation
| < POWER: "^" >                                  // x to the power of y
| < REM: "MOD" >                                  // reminder spelled "MOD"
| < DIV: "\\" >                                   // DIV spelled "\\"
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       /*
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff",
       */
       "_",
       "$"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"
       /*
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
       */
      ]
  >
}


/*********************************************
 * THE CFSCRIPT LANGUAGE GRAMMAR STARTS HERE *
 *********************************************/

/**
 * Main entry point of the parser.  This rule parses an entire
 * CFScript program.
 */
void parse() :
{
    Token t;
}
{                      { m_handler.handleStart();      } ( W() )*
    ( <UNICODE_BOM> )?
    (
      t=<CDO>          { m_handler.handleCDO(t.image); } ( W() )*
    )?
    ( Element() )*
    (
      t=<CDC>          { m_handler.handleCDC(t.image); } ( W() )*
      |
      t=<CRIPPLED_SINGLE_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.CRIPPLED_SINGLE_LINE_COMMENT); }
    )?
    <EOF>              { m_handler.handleFinish(); }
}


void W() :
    {
    Token t;
    }
    { t=<S>            { m_handler.handleWhite    (t.image); }
    | t=<L>            { m_handler.handleEndOfLine(t.image); }
    | t=<SINGLE_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.SINGLE_LINE_COMMENT); }
    | t=<MULTI_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.MULTI_LINE_COMMENT); }
    }


void Element() :
{
    Token t, t1;
}
{
// CvdL: JScript can have "function document.onReadStateChange() {}"
    (
      t=<FUNCTION>     { m_handler.handleKeyword(t.image);  } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
      (
        t="."          { m_handler.handleOperator(t.image); } ( W() )*
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
      )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      ( ParameterList() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      CompoundStatement()
    |
      Statement()
    )
}

// Returns a Vector of strings, one for each identifier.
void ParameterList() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image);  } ( W() )*
    (
      t=","            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
    )*
}

void CompoundStatement() :
{
    Token t;
}
{
    t="{"              { m_handler.handleOperator(t.image); } ( W() )*
    ( Statement() )*
    t="}"              { m_handler.handleOperator(t.image); } ( W() )*
}


void Statement() :
{
    Token t;
}
{
    ( /* empty statement */
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    |
      /* labeled statement */
      LOOKAHEAD(2)
      t=<IDENTIFIER>   { m_handler.handleLiteral (t.image); }
      /* NO WHITESPACE HERE */
      t=":"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<IF>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      Statement()
      ( LOOKAHEAD(1)
        t=<ELSE>       { m_handler.handleKeyword(t.image);  } ( W() )*
        Statement()
      )?
    |
      t=<WHILE>        { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      Statement()
    |
      t=<DO>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Statement()
      t=<WHILE>        { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      // semicolon!!
    |
      LOOKAHEAD( <FOR> (W())* "(" (W())* ";" )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      LOOKAHEAD( <FOR> (W())* "(" (W())* VariablesOrExpression() ";" )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      VariablesOrExpression()
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      LOOKAHEAD (<FOR> (W())* "(" (W())* <IDENTIFIER> (W())* <IN> )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
      t=<IN>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Expression()
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<WITH>         { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<TRY>          { m_handler.handleKeyword(t.image);  } ( W() )*
      Statement()
      t=<CATCH>        { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<THROW>        { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    |
      t=<BREAK>        { m_handler.handleKeyword(t.image);  } ( W() )*
      (
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
      )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    |
      t=<CONTINUE>     { m_handler.handleKeyword(t.image);  } ( W() )*
      (
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
      )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    |
      t=<RETURN>       { m_handler.handleKeyword(t.image);  } ( W() )*
      ( Expression() )?
      ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      )?
    |
      SwitchStatement()
    |
      CompoundStatement()
    |
      VariablesOrExpression()
      ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      )?
    )
}

void SwitchStatement() :
{
    Token t;
}
{
    t=<SWITCH>         { m_handler.handleKeyword(t.image);  } ( W() )*
    t="("              { m_handler.handleOperator(t.image); } ( W() )*
    Expression()
    t=")"              { m_handler.handleOperator(t.image); } ( W() )*
    t="{"              { m_handler.handleOperator(t.image); } ( W() )*
    (
      CaseLabel()
    | CaseDefaultLabel()
    )*
    t="}"              { m_handler.handleOperator(t.image); } ( W() )*
}

void CaseLabel() :
{
    Token t;
}
{
    t=<CASE>           { m_handler.handleKeyword(t.image);  } ( W() )*
    Expression()
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    ( LOOKAHEAD(1)
      Statement()
    )*
    ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    )?
}

void CaseDefaultLabel() :
{
    Token t;
}
{
    t=<_DEFAULT>       { m_handler.handleKeyword(t.image);  } ( W() )*
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    ( LOOKAHEAD(1)
      Statement()
    )*
    ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    )?
}

void Condition() :
{
    Token t;
}
{
    t="("              { m_handler.handleOperator(t.image); } ( W() )*
    Expression()
    t=")"              { m_handler.handleOperator(t.image); } ( W() )*
}

// ### Check up on the semantics of this - not sure whether it should
// be statement or expression
void VariablesOrExpression() :
{
    Token t;
}
{
    (
      t=<VAR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      Variables()
    |
      Expression()
  )
}

// Vector of JSVarDecl's
void Variables() :
{
    Token t;
}
{
  Variable() ( W() )*
  (
    t=","              { m_handler.handleOperator(t.image); } ( W() )*
    Variable()
  )*
}

void Variable() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image);  }
    ( LOOKAHEAD(1) W() )*
    (
      t="="            { m_handler.handleOperator(t.image); } ( W() )*
      AssignmentExpression()
    )?
}

void Expression() :
{
    Token t;
}
{ // CF: may not exist
  AssignmentExpression() ( W() )*
  (
    t=","              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
  )*
}

void AssignmentExpression() :
{
    Token t;
}
{
  ConditionalExpression()
  (
    LOOKAHEAD(1)
    ( t=<ASSIGN> )
        {
        m_handler.handleOperator(t.image);
        }
    ( W() )*
    ConditionalExpression()
  )*
}

void ConditionalExpression() :
{
    Token t;
}
{
  OrExpression()
    // CF: does not exist
  (
    t="?"              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
  )?
}

void OrExpression() :
{
    Token t;
}
{
    AndExpression()
    (
      t=<OR>           { m_handler.handleOperator(t.image); } ( W() )*
      AndExpression()
    )*
}

void AndExpression() :
{
    Token t;
}
{
    BitwiseOrExpression()
    (
      t=<AND>           { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseOrExpression()
    )*
}

void BitwiseOrExpression() :
{
    Token t;
}
{
    BitwiseXorExpression()
    (
      t="|"            { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseXorExpression()
    )*
}

void BitwiseXorExpression() :
{
    Token t;
}
{
    BitwiseAndExpression()
    (
      t="^"            { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseAndExpression()
    )*
}

void BitwiseAndExpression() :
{
    Token t;
}
{
    EqualityExpression()
    (
      t="&"            { m_handler.handleOperator(t.image); } ( W() )*
      EqualityExpression()
    )*
}

void EqualityExpression() :
{
    Token t;
}
{
    InstanceOfExpression()
    (
      // the "in" operator is treated like a boolean comparison operator
      LOOKAHEAD(1)
      (
        ( t="==" | t="!=" | t="===" | t="!==" )
          {
          m_handler.handleOperator(t.image);
          }
        |
          t="in"
          {
          m_handler.handleKeyword(t.image);
          }
        )
      ( W() )* InstanceOfExpression()
    )*
}

// this routine is mirrored after the Java1.1 grammar.
void InstanceOfExpression() :
{
    Token t;
}
{
    RelationalExpression()
      (
        t=<INSTANCEOF>
        {
        m_handler.handleKeyword(t.image);
        }
        // here comes actually a type expression
        ( W() )* MemberExpression()
      )?
}

void RelationalExpression() :
{
    Token t;
}
{
    ShiftExpression()
    (
      ( t=<IS> | t=<EQ> | t=<IS_NOT> | t=<NOT_EQUAL> |
        t=<NEQ> | t=<CONTAINS> | t=<DOES_NOT_CONTAIN> |
        t=<GREATER_THAN> | t=<GT> | t=<LESS_THAN> | t=<LT> |
        t=<GREATER_THAN_OR_EQ_TO> | t=<GTE> | t=<GE> |
        t=<LESS_THAN_OR_EQ_TO> | t=<LTE> | t=<LE>
      )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* ShiftExpression()
    )*
}

void ShiftExpression() :
{
    Token t;
}
{
    // There's not really a shift-expression in CFScript
    AdditiveExpression()
    (
      ( t="<<" | t=">>" )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* AdditiveExpression()
    )*
}

void AdditiveExpression() :
{
    Token t;
}
{
    MultiplicativeExpression()
    (
      LOOKAHEAD(1)
      ( t=<PLUS> | t=<MINUS> )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* MultiplicativeExpression()
    )*
}

void MultiplicativeExpression() :
{
    Token t;
}
{
    UnaryExpression()
    (
      ( t=<STAR> | t=<SLASH> | t=<REM> | t=<DIV> )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* UnaryExpression()
    )*
}

void UnaryExpression() :
{
    Token t;
}
{
    (
      t=<NOT>             { m_handler.handleOperator(t.image); } ( W() )*
      UnaryExpression()
    |
      t="-"               { m_handler.handleOperator(t.image); } ( W() )*
      UnaryExpression()
    |
      LOOKAHEAD(1)
      ( t="++" | t="--" ) { m_handler.handleOperator(t.image); } ( W() )*
      MemberExpression()
    |
      MemberExpression()
      (
        LOOKAHEAD(1)
        ( t="++" | t="--" ) { m_handler.handleOperator(t.image); }
        ( LOOKAHEAD(1) W() )*
      )?
    |
      /* NEW is not really a unary expression
      t=<NEW>               { m_handler.handleKeyword(t.image); } ( W() )*
      Constructor()
    |
      */
      t=<DELETE>            { m_handler.handleKeyword(t.image); } ( W() )*
      MemberExpression()
    |
      t=<TYPEOF>            { m_handler.handleKeyword(t.image); } ( W() )*
      MemberExpression()
    )
}

void Constructor() :
{
}
{
    ConstructorCall()
}

void ConstructorCall() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image); }
    ( LOOKAHEAD(1) W() )*
    (
      t="."            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image); }
      ( LOOKAHEAD(1) W() )*
    )*
    (
      LOOKAHEAD(1)
      t="("            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
      ( ArgumentList() )?
      t=")"            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
    )?
}

// Departs from the grammar in the standard, since this works in all browsers
void MemberExpression() :
{
    Token t;
}
{
    PrimaryExpression()
    (
      t="."            { m_handler.handleOperator(t.image); } ( W() )*
      PrimaryExpression()
    |
      t="["            { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      t="]"            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
    |
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      ( ArgumentList() )?
      t=")"            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
    )*
}

// Vector of JSExpressions
void ArgumentList() :
{
    Token t;
}
{
    AssignmentExpression()
    (
      t=","            { m_handler.handleOperator(t.image); } ( W() )*
      AssignmentExpression()
    )*
}

void PrimaryExpression() :
{
    Token t;
}
{
  (
    t="("
        {
        m_handler.handleOperator(t.image);
        }
    ( W() )*
    Expression()
    t=")"
        {
        m_handler.handleOperator(t.image);
        }
    ( LOOKAHEAD(1) W() )*
  |
    t="#"
        {
        m_handler.handleOperator(t.image);
        }
    ( W() )*
    Expression()
    t="#"
        {
        m_handler.handleOperator(t.image);
        }
    ( LOOKAHEAD(1) W() )*
  |
    t=<IDENTIFIER>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<INTEGER_LITERAL>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<FLOATING_POINT_LITERAL>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<STRING_LITERAL>
          {
          m_handler.handleString(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<BOOLEAN_LITERAL>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<NULL_LITERAL>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
    t=<THIS>
          {
          m_handler.handleLiteral(t.image);
          }
    ( LOOKAHEAD(1) W() )*
  |
      t=<NEW>
          {
          m_handler.handleKeyword(t.image);
          }
    ( LOOKAHEAD(1) W() )*
    Constructor()
  )
}

