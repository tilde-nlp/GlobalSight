//  -*- Mode: Java -*-
/*
 * Copyright (c) 2000 GlobalSight Corporation. All rights reserved.
 *
 * THIS DOCUMENT CONTAINS TRADE SECRET DATA WHICH IS THE PROPERTY OF
 * GLOBALSIGHT CORPORATION. THIS DOCUMENT IS SUBMITTED TO RECIPIENT
 * IN CONFIDENCE. INFORMATION CONTAINED HEREIN MAY NOT BE USED, COPIED
 * OR DISCLOSED IN WHOLE OR IN PART EXCEPT AS PERMITTED BY WRITTEN
 * AGREEMENT SIGNED BY AN OFFICER OF GLOBALSIGHT CORPORATION.
 *
 * THIS MATERIAL IS ALSO COPYRIGHTED AS AN UNPUBLISHED WORK UNDER
 * SECTIONS 104 AND 408 OF TITLE 17 OF THE UNITED STATES CODE.
 * UNAUTHORIZED USE, COPYING OR OTHER REPRODUCTION IS PROHIBITED
 * BY LAW.
 */

/*
Javacc grammar file for SGML.
Author: Cornelis Van Der Laan Thu Apr 22 20:20:36 2004
*/

options
{
    IGNORE_CASE = true;
    STATIC = false;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = true;
    DEBUG_PARSER = false;
    DEBUG_TOKEN_MANAGER = false;
    DEBUG_LOOKAHEAD = false;
}

/*
options
{
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = true;
}
*/

PARSER_BEGIN(Parser)
package com.globalsight.ling.docproc.extractor.sgml;

import com.globalsight.ling.docproc.extractor.sgml.SgmlObjects;
import com.globalsight.ling.docproc.extractor.sgml.ISgmlHandler;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;

/**
 * <p>A SGML Parser automatically generated by JavaCC.  Builds an SGML
 * Object Model and sends events to abstract handler methods in type
 * {@link ISgmlHandler}, which are implemented by class
 * ExtractionHandler.
 *
 * @see SgmlObjects
 * @see ISgmlHandler
 * @see ExtractionHandler
 */
public class Parser
    implements SgmlObjects
{
    ISgmlHandler m_handler = null;

    public static void main(String args[])
        throws ParseException
    {
        Parser parser = new Parser (System.in);
        parser.parse();
    }

    public void setHandler(ISgmlHandler p_handler)
    {
        m_handler = p_handler;
    }

    /**
     * <p>Return the current line number in the input file.  This is a
     * little helper that allows us to offset error positions obtained
     * from embedded extractors.  Embedded extractors receive a fresh
     * input object and start counting lines and columns from 1.</p>
     */
    public int getCurrentLine()
    {
        return jj_input_stream.line;
    }

    /**
     * <p>Return the current column number in the input file.  This is a
     * little helper that allows us to offset error positions obtained
     * from embedded extractors.  Embedded extractors receive a fresh
     * input object and start counting lines and columns from 1.</p>
     */
    public int getCurrentColumn()
    {
        return jj_input_stream.column;
    }

    /**
     * Returns the original text including whitespace that occured
     * between two tokens. Leading whitespace before the first token
     * is *not* returned. The tokens cannot be the same.
     */
    private String getTokenText(Token first, Token last)
    {
        StringBuffer res = new StringBuffer();

        res.append(first.image);

        for (Token t = first.next; t != last.next; t = t.next)
        {
            if (t.specialToken != null)
            {
                Token tt = t.specialToken;

                // walk the list backwards
                while (tt.specialToken != null)
                {
                    tt = tt.specialToken;
                }

                // and forwards again
                for (; tt != null; tt = tt.next)
                {
                    res.append(tt.image);
                }
            }

            res.append(t.image);
        }

        return res.toString();
    }
}
PARSER_END(Parser)

/* LEXICAL DEFINITIONS */

<*> TOKEN :
{
  <#ALPHA_CHAR: ["a"-"z", "A"-"Z"] >
| <#NUM_CHAR:   ["0"-"9"] >
| <#ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >
// Identifier chars for tag and attribute names:
// ":" is for namespace separators in tags & attributes,
// "#" is for ColdFusion variable substitutions.
| <#IDENTIFIER_CHAR:
    [ "a"-"z", "A"-"Z", "0"-"9", "_", "-", ".", ":", "#"] >
| <#IDENTIFIER: <IDENTIFIER_CHAR> (<IDENTIFIER_CHAR>)* >
| <#QUOTED_STRING:
    ( "'" ( ~["'"] )* "'" ) | ( "\"" ( ~["\""] )* "\"" ) >
// Allow wrongly quoted attributes like VALUE=text".
| <#WRONGLY_QUOTED_STRING:
  ( ~[">", "\"", "'", " ", "\t", "\n", "\r"] )+ ( ["\"", "'"] )? >
| <#NEWLINE:    ( /*"\r\n" |*/ "\r" | "\n" ) >
| <#WHITESPACE: ( " " | "\t" ) >
| <UNICODE_BOM: ("\uFEFF"|"\uFFFE") >
}

<DEFAULT> TOKEN :
{
  <CR_NEWLINE:     (<NEWLINE>)+ >
| <TAG_START:        "<"       > : StartTag
| <ENDTAG_START:     "</"      > : StartTag
| <COMMENT_START:    "<!--"    > : InComment
| <DECL_START:       "<!"      > : InDeclaration
| <PI_START:         "<?"      > : InProcessingInstruction
//| <ENTITY_START:   "&"       > : InEntity
| <PCDATA:         (~["<", "\r", "\n"])+>
}

<StartTag> TOKEN :
{
/*
  <SCRIPT: "SCRIPT"> : InTag
| <STYLE:  "STYLE">  : InTag
| <JAVA:   "JAVA">   : InTag                      // JHTML <JAVA> tag
|
*/
 <TAG_NAME:         <IDENTIFIER>   >  : InTag
| <LST_ERROR: ~[]>   : DEFAULT
}

<AttrVal> SPECIAL_TOKEN :
{
  < (<WHITESPACE>|<NEWLINE>)+ >
}

<AttrVal> TOKEN :
{
  <ATTR_VALUE:
    ( <QUOTED_STRING>
    | /* Allow wrongly quoted attributes like VALUE=text" */
      <WRONGLY_QUOTED_STRING>
    )
  > /*: InTag*/
| <LAV_ERROR: ~[]>
}

<InTag> SPECIAL_TOKEN :
{
  < (<WHITESPACE>|<NEWLINE>)+ >
}

<InTag> TOKEN :
{
  <TAG_END: ">" >                       : DEFAULT
| <TAG_END_CLOSE: "/" (<WHITESPACE>|<NEWLINE>)* ">" > : DEFAULT
}

<InTag> TOKEN :
{
  <ATTR_NAME: <IDENTIFIER> >
| <EQUAL: "=" >                         : AttrVal
| <LIT_ERROR: ~[]>
}

/*
<InScript> TOKEN :
{
  <SCRIPT_END: "</SCRIPT>" > : DEFAULT
| <SCRIPT_TEXT:  ~[] >
}

<InJava> TOKEN :
{
  <JAVA_END: "</JAVA>" > : DEFAULT
| <JAVA_TEXT:  ~[] >
}

<InStyle> TOKEN :
{
  <STYLE_END:   "</STYLE>" > : DEFAULT
| <STYLE_TEXT:  ~[] >
}

<InStyle> MORE:
{
  < "<!--" > : InCommentedStyle
}

<InCommentedStyle> MORE:
{
  < ~[] >
}

<InCommentedStyle> TOKEN:
{
  < COMMENTED_STYLE_TEXT: "-->" > : InStyle
}
*/

<InComment> SPECIAL_TOKEN :
{
  < (<NEWLINE>)+ >
}

<InComment> TOKEN :
{
  < COMMENT_END:  "-->" > : DEFAULT
| < DASH:         "-" >
| < COMMENT_WORD: (~["-"])+ >
}

<InDeclaration> TOKEN :
{
  <DECL_ANY: (~[">"])+ >
| <DECL_END: ">" > : DEFAULT
}

<InProcessingInstruction> TOKEN :
{
  <PI_ANY: (~[">"])+ >
| <PI_END: ">" > : DEFAULT
}

/*
<InEntity> TOKEN :
{
  <ENTITY_END:   ";" > : DEFAULT
| <NUMERIC_ENTITY:  ("#" ("x")? (["0"-"9", "a"-"f"])+) >
| <CHAR_ENTITY:  (<IDENTIFIER_CHAR>)+ >
}
*/

/* START OF GRAMMAR */

void parse() :
{
    Token text;
    Tag t1;
    /*
    Script t2;
    Style t3;
    Java t4;
    */
    EndTag t9;
}
{
    { m_handler.handleStart(); }

    (<UNICODE_BOM>)?

    ( LOOKAHEAD(2) t1=parseStartTag()   { m_handler.handleStartTag(t1); }
    /*
    | LOOKAHEAD(2) t2=parseScript()     { m_handler.handleScript(t2); }
    | LOOKAHEAD(2) t3=parseStyle()      { m_handler.handleStyle(t3); }
    | LOOKAHEAD(2) t4=parseJava()       { m_handler.handleJava(t4); }
    */
    | t9=parseEndTag()                  { m_handler.handleEndTag(t9); }
    | parseComment()
    | parseDeclaration()
    | parseProcessingInstruction()
    /*
    | LOOKAHEAD(2) <TAG_START> text=<LST_ERROR>
            {
            m_handler.handleText(new Text("<" + text.image));
            }
    */
    | parseText()
    | parseNewline()
    )*

    <EOF>

    { m_handler.handleFinish(); }
}

void parseComment() :
{
    Token t;
    StringBuffer s = new StringBuffer ("");
}
{
    <COMMENT_START>
    (
      t=<DASH>
            {
            s.append(t.image);
            }
    |
      t=<COMMENT_WORD>
            {
            s.append(t.image);
            }
    )*
    <COMMENT_END>
            {
            m_handler.handleComment(new Comment(s.toString()));
            }
}

void parseProcessingInstruction() :
{
    Token t;
}
{
    <PI_START> t=<PI_ANY> <PI_END>
         {
         m_handler.handlePI(new PI(t.image));
         }
}

void parseDeclaration() :
{
    Token t;
}
{
    <DECL_START> t=<DECL_ANY> <DECL_END>
         {
         m_handler.handleDeclaration(new Declaration(t.image));
         }
}

Attribute parseAttribute(int p_state) :
{
    Token t1, t2 = null;
}
{
    t1=<ATTR_NAME> ( <EQUAL> t2=<ATTR_VALUE> )?
        {
        token_source.SwitchTo(p_state);

        if (t2 == null)
        {
            return new Attribute(t1.image);
        }
        else
        {
            String temp = t2.image;
            char lastChar  = temp.charAt(temp.length() - 1);
            char firstChar = temp.charAt(0);
            if ((lastChar != firstChar) &&
                (lastChar == '"' || lastChar == '\''))
            {
                // Must be one of them sickly quoted attributes.
                // Repair att=val" to att="val"
                temp = lastChar + temp;
            }

            // Handle CDATA: should ignore \n and replace \r\t with space.
            // However, we remove \r\n and leave \t alone.
            int i_at;
            while ((i_at = temp.indexOf('\n')) >= 0)
            {
                temp = temp.substring(0, i_at) + temp.substring(i_at + 1);
            }
            while ((i_at = temp.indexOf('\r')) >= 0)
            {
            temp = temp.substring(0, i_at) + temp.substring(i_at + 1);
            }

            return new Attribute(t1.image, temp);
        }
        }
}

AttributeList parseAttributeList() :
{
    AttributeList alist = new AttributeList();
    Attribute a;
}
{
    (
      a=parseAttribute(token_source.curLexState)
            {
            alist.addAttribute(a);
            }
    )*
      {
          return alist;
      }
}

ExtendedAttributeList parseExtendedAttributeList() :
{
    ExtendedAttributeList elist = new ExtendedAttributeList();
    AttributeList alist;
    Attribute a;
    Token t, t1, tag;
    EndTag e;
}
{
    (
      a=parseAttribute(token_source.curLexState)
            {
            elist.addAttribute(a);
            }
    )*
      {
          return elist;
      }
}

Tag parseStartTag() :
{
    Token t, tag, t1;
    ExtendedAttributeList elist = null;
    Token firstToken = getToken(1);
    boolean b_closed = false;
}
{
    try
    {
        t=<TAG_START> tag=<TAG_NAME> elist=parseExtendedAttributeList()
        (
          t1=<TAG_END>
        | t1=<TAG_END_CLOSE>       { b_closed = true; }
        )
        {
        token_source.SwitchTo(DEFAULT);

        return new Tag(tag.image, elist, b_closed,
            getTokenText(t, t1), t.beginLine, t.beginColumn);
        }
    }
    catch (ParseException e)
    {
        token_source.SwitchTo(DEFAULT);
        String s = getTokenText(firstToken, getNextToken());
        throw new ParseException("Error parsing STARTTAG:\n" +
            e.getMessage() + "\nin input: " + s);
    }
}

/*
Script parseScript() :
{
    Token t, t1, t2, t3, tag;
    StringBuffer b = new StringBuffer();
    ExtendedAttributeList elist;
}
{
    t=<TAG_START> tag=<SCRIPT> elist=parseExtendedAttributeList()
    (
      t1=<TAG_END_CLOSE>
            {
            return new Script(tag.image, elist, true,
                getTokenText(t, t1), "", t.beginLine, t.beginColumn);
            }
    | t1=<TAG_END>          { token_source.SwitchTo(InScript); }
      (
        t2=<SCRIPT_TEXT>    { b.append(t2.image); }
      )*
      t3=<SCRIPT_END>
            {
            String text = b.toString();

            return new Script(tag.image, elist, false,
                getTokenText(t, t3), text, t.beginLine, t.beginColumn);
            }
    )
}

Java parseJava() :
{
    Token t, t1, t2, t3, tag;
    StringBuffer b = new StringBuffer();
    ExtendedAttributeList elist;
}
{
    t=<TAG_START> tag=<JAVA> elist=parseExtendedAttributeList()
    (
      t1=<TAG_END_CLOSE>
            {
            return new Java(tag.image, elist, true,
                getTokenText(t, t1), "", t.beginLine, t.beginColumn);
            }
    | t1=<TAG_END>          { token_source.SwitchTo(InJava); }
      (
        t2=<JAVA_TEXT>      { b.append(t2.image); }
      )*
      t3=<JAVA_END>
            {
            String text = b.toString();

            return new Java(tag.image, elist, false,
                getTokenText(t, t3), text, t.beginLine, t.beginColumn);
            }
    )
}

Style parseStyle() :
{
    Token t, t1, t2, t3, tag;
    StringBuffer b = new StringBuffer();
    ExtendedAttributeList elist;
}
{
    t=<TAG_START> tag=<STYLE> elist=parseExtendedAttributeList()
    (
      t1=<TAG_END_CLOSE>
            {
            return new Style(tag.image, elist, true,
                getTokenText(t, t1), "", t.beginLine, t.beginColumn);
            }
    | t1=<TAG_END>                { token_source.SwitchTo(InStyle); }
      (
        t2=<STYLE_TEXT>           { b.append(t2.image); }
      |
        t2=<COMMENTED_STYLE_TEXT> { b.append(t2.image); }
      )*
      t3=<STYLE_END>
            {
            String text = b.toString();

            return new Style(tag.image, elist, false,
                getTokenText(t, t3), text, t.beginLine, t.beginColumn);
            }
    )
}
*/

EndTag parseEndTag() :
{
    Token t;
}
{
    <ENDTAG_START>
    (
      t=<TAG_NAME> <TAG_END>
    )
        {
            return new EndTag(t.image);
        }
}

void parseText() :
{
    Token t;
}
{
    t=<PCDATA>
        {
        m_handler.handleText(new Text(t.image));
        }
}

void parseNewline() :
{
    Token t;
}
{
    t=<CR_NEWLINE>
        {
        m_handler.handleNewline(new Newline(t.image));
        }
}

/*
void parseEntity() : { }
{
<ENTITY_START> (<NUMERIC_ENTITY> | <CHAR_ENTITY>) <ENTITY_END>

{entity();}
}
*/

