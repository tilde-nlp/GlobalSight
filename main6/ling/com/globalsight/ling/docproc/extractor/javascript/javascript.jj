// -*- Mode: Java -*-
/*
 * Copyright (c) 2000 GlobalSight Corporation. All rights reserved.
 *
 * THIS DOCUMENT CONTAINS TRADE SECRET DATA WHICH IS THE PROPERTY OF
 * GLOBALSIGHT CORPORATION. THIS DOCUMENT IS SUBMITTED TO RECIPIENT
 * IN CONFIDENCE. INFORMATION CONTAINED HEREIN MAY NOT BE USED, COPIED
 * OR DISCLOSED IN WHOLE OR IN PART EXCEPT AS PERMITTED BY WRITTEN
 * AGREEMENT SIGNED BY AN OFFICER OF GLOBALSIGHT CORPORATION.
 *
 * THIS MATERIAL IS ALSO COPYRIGHTED AS AN UNPUBLISHED WORK UNDER
 * SECTIONS 104 AND 408 OF TITLE 17 OF THE UNITED STATES CODE.
 * UNAUTHORIZED USE, COPYING OR OTHER REPRODUCTION IS PROHIBITED
 * BY LAW.
 */

/*
 * Copyright (C) 1996 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may,
 * however, make any modifications you wish to this file.
 *
 * Java files generated by running Jack on this file (or modified
 * versions of this file) may be used in exactly the same manner as
 * Java files generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 6/11/96
 *
 * This file contains a Javascript grammar and actions that implement
 * a front-end.
 */

/*
 * Fri Dec 01 00:37:52 2000 CvdL: this grammar has been heavily
 * modified and corrected by me.
 *
 * Latest changes:
 * Fri Dec 01 00:38:33 2000: addition of JavaScript 1.4 "in" and
 *   "instanceof" operators.
 * Wed Mar 28 17:49:41 2001: addition of JavaScript 1.4 "finally".
 *  - Addition of do-while.
 *  - Comment handling like IE, i.e. <!-- behaves like // and -->
 *    is allowed before EOF.
 *  - Labels can have whitespace between <ID> and <COLON>.
 * Tue Mar 26 10:47:02 2002: Added regular expression literals.
 */

options {
  STATIC = false;
  LOOKAHEAD = 1;
  DEBUG_PARSER = false;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  //DEBUG_TOKEN_MANAGER = true;
}


PARSER_BEGIN(Parser)
package com.globalsight.ling.docproc.extractor.javascript;

/**
 * <p>A JavaScript Parser automatically generated by JavaCC.</p>
 * <p>Fires {@link
 * com.globalsight.ling.docproc.extractor.javascript.IParseEvents
 * IParseEvents}.</p>
 */
public class Parser
{
    private IParseEvents m_handler = null;

    public void setHandler(IParseEvents handler)
    {
        m_handler = handler;
    }

    private void appendToken(Token t1, String s, Token t2)
    {
        t1.image = t1.image + ((s != null) ? s : "") + t2.image;
        t1.endLine = t2.endLine;
        t1.endColumn = t2.endColumn;
        t1.next = t2.next;
    }

}
PARSER_END(Parser)


// DEF 7656 - Regex literal problem.
// To prevent two divisions or a division and a comment from being
// recognized as a regular expression literal, we use lexical
// state. After some tokens are tokenized, we move the lexical state
// to RE. Regular expression literal is recognized by Token Manager
// only when the lexical state is RE. Those tokens that change the
// state to RE are currently "(", "=", ",", "?" and ":". We may need
// to add some more as needed. The other tokens change the state to
// DEFAULT except for white spaces, comments and sgml separators. They
// carry over the state.

<*> TOKEN : /* WHITE SPACE - \u001a=^Z, \u00a0=nbsp */
{
  <S: (" " | "\t" | "\f" | "\u001a" | "\u00a0")+ >
|
  <L: ("\n" | "\r" | "\r\n")+ >
|
  <UNICODE_BOM: ("\uFEFF"|"\uFFFE") >
}

<*> TOKEN : /* SGML SEPARATORS */
{
  <CDO: "<!--" ("-")* >
|
  <CDC: "--" ("-")* ">" >
}


<*> TOKEN : /* COMMENTS */
{
  // IE handles "<!--" like "//" and does not expect a closing "-->".
  // <SCRIPT><!-- alert(1); --></SCRIPT> is *NOT* executed.
  <SINGLE_LINE_COMMENT:
    ("//" | <CDO>) (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
|
  /* This one can only occur immediately before EOF */
  <CRIPPLED_SINGLE_LINE_COMMENT:
    // "//" (~["\n","\r"])* ( <CDC> (~["\n","\r"])* )? >
    ("//" | <CDO>) (~["\n","\r"])* >
|
  <MULTI_LINE_COMMENT:
    "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
|
  <JAVA_CODE:
    "<%" ~["="] (~["%"])* "%>" >    
}

<*> TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" > : DEFAULT
| < BOOLEAN: "boolean" > : DEFAULT
| < BREAK: "break" > : DEFAULT
| < BYTE: "byte" > : DEFAULT
| < CASE: "case" > : DEFAULT
| < CATCH: "catch" > : DEFAULT
| < CHAR: "char" > : DEFAULT
| < CLASS: "class" > : DEFAULT
| < CONST: "const" > : DEFAULT
| < CONTINUE: "continue" > : DEFAULT
| < _DEFAULT: "default" > : DEFAULT
| < DELETE: "delete" > : DEFAULT
| < DO: "do" > : DEFAULT
| < DOUBLE: "double" > : DEFAULT
| < ELSE: "else" > : DEFAULT
| < EXTENDS: "extends" > : DEFAULT
| < FINAL: "final" > : DEFAULT
| < FINALLY: "finally" > : DEFAULT
| < FLOAT: "float" > : DEFAULT
| < FOR: "for" > : DEFAULT
| < FUNCTION: "function" > : DEFAULT
| < GOTO: "goto" > : DEFAULT
| < IF: "if" > : DEFAULT
| < IMPLEMENTS: "implements" > : DEFAULT
| < IMPORT: "import" > : DEFAULT
| < IN: "in" > : DEFAULT
| < INSTANCEOF: "instanceof" > : DEFAULT
| < INT: "int" > : DEFAULT
| < INTERFACE: "interface" > : DEFAULT
| < LONG: "long" > : DEFAULT
| < NATIVE: "native" > : DEFAULT
| < NEW: "new" > : DEFAULT
| < PACKAGE: "package"> : DEFAULT
| < PRIVATE: "private" > : DEFAULT
| < PROTECTED: "protected" > : DEFAULT
| < PUBLIC: "public" > : DEFAULT
| < RETURN: "return" > : DEFAULT
| < SHORT: "short" > : DEFAULT
| < STATIC: "static" > : DEFAULT
| < SUPER: "super" > : DEFAULT
| < SWITCH: "switch" > : DEFAULT
| < SYNCHRONIZED: "synchronized" > : DEFAULT
| < THIS: "this" > : DEFAULT
| < THROW: "throw" > : DEFAULT
| < THROWS: "throws" > : DEFAULT
| < TRANSIENT: "transient" > : DEFAULT
| < TRY: "try" > : DEFAULT
| < TYPEOF: "typeof" > : DEFAULT  // CvdL: this is both a function and operator
| < VAR: "var"> : DEFAULT
| < VOID: "void" > : DEFAULT
| < VOLATILE: "volatile" > : DEFAULT
| < WHILE: "while" > : DEFAULT
| < WITH: "with" > : DEFAULT
}

<*> TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  > : DEFAULT
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ (<EXPONENT>)?
  > : DEFAULT
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
    "\""
        // Bug 2133: DAE's Javascript strings contain illegal
        // newlines and we cannot make DAE change them.
        // So instead we read them and ExtractionHandler deletes
        // them from the string - which is the correct reaction.
        // (   (~["\"","\\","\n","\r"])
        (   (~["\"","\\"])
        | <ESCAPE_SEQUENCE>
        | ( "<%" ( ~[">"] )+ "%>" )
        )*
        "\""
      | "'"
        // (   (~["'","\\","\n","\r"])
        (   (~["'","\\"])
        | <ESCAPE_SEQUENCE>
        )*
        "'"
  > : DEFAULT
|
  < #ESCAPE_SEQUENCE:
      "\\"
        ( ["n","t","b","r","f","\\","'","\""]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        | "x" ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
        | "u" ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
              ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
          // NONESCAPECHARACTER - any other single char
        | (~["n","t","b","r","f","\\","'","\"","u","x","0"-"9","\n","\r"])
        )
  >
|
  < BOOLEAN_LITERAL: "true" | "false" > : DEFAULT
|
  < NULL_LITERAL: "null" > : DEFAULT
|
  < CF_VARIABLE: "#" (~["#", "\n", "\r"])+ "#" > : DEFAULT
}

// Regular expression
// It is recognized as token only when the lexical state is RE.
<RE> TOKEN :
{
  // JScript knows at least g,i,m
  < #REGEXP_MODIFIER: ["g", "i", "m", "s"] >
|
  < REGEXP_LITERAL:
      "/"
      ( ~["/", "\n", "\r"] | "\\/" )+
      "/"
      ( <REGEXP_MODIFIER> )*
  > : DEFAULT
}

<*> TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: 
    <LETTER> (<LETTER>|<DIGIT>)* 
  > : DEFAULT
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       /*
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff",
       */
       "_",
       "$"
      ]
      |
    "<%=" (~["%", ">"])* "%>" 
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"
       /*
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
       */
      ]
  >
}

<*> TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" > : RE
| < RPAREN: ")" > : DEFAULT
| < LBRACE: "{" > : DEFAULT
| < RBRACE: "}" > : DEFAULT
| < LBRACKET: "[" > : DEFAULT
| < RBRACKET: "]" > : DEFAULT
| < SEMICOLON: ";" > : DEFAULT
| < COMMA: "," > : RE
}

<*> TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" > : RE
| < GT: ">" > : DEFAULT
| < LT: "<" > : DEFAULT
| < BANG: "!" > : DEFAULT
| < TILDE: "~" > : DEFAULT
| < HOOK: "?" > : RE
| < COLON: ":" > : RE
| < DOT: "." > : DEFAULT
| < EQ: "==" > : DEFAULT
| < LE: "<=" > : DEFAULT
| < GE: ">=" > : DEFAULT
| < NE: "!=" > : DEFAULT
| < IDENTITY: "===" > : DEFAULT                  // MS extension
| < NONIDENTITY: "!==" > : DEFAULT               // MS extension
| < SC_OR: "||" > : DEFAULT
| < SC_AND: "&&" > : DEFAULT
| < INCR: "++" > : DEFAULT
| < DECR: "--" > : DEFAULT
| < PLUS: "+" > : DEFAULT
| < MINUS: "-" > : DEFAULT
| < STAR: "*" > : DEFAULT
| < SLASH: "/" > : DEFAULT
| < BIT_AND: "&" > : DEFAULT
| < BIT_OR: "|" > : DEFAULT
| < XOR: "^" > : DEFAULT
| < REM: "%" > : DEFAULT
| < LSHIFT: "<<" > : DEFAULT
| < RSIGNEDSHIFT: ">>" > : DEFAULT
| < RUNSIGNEDSHIFT: ">>>" > : DEFAULT
| < SC_ORASSIGN: "||=" > : DEFAULT
| < SC_ANDASSIGN: "&&=" > : DEFAULT
| < PLUSASSIGN: "+=" > : DEFAULT
| < MINUSASSIGN: "-=" > : DEFAULT
| < STARASSIGN: "*=" > : DEFAULT
| < SLASHASSIGN: "/=" > : DEFAULT
| < BIT_ANDASSIGN: "&=" > : DEFAULT
| < BIT_ORASSIGN: "|=" > : DEFAULT
| < XORASSIGN: "^=" > : DEFAULT
| < REMASSIGN: "%=" > : DEFAULT
| < LSHIFTASSIGN: "<<=" > : DEFAULT
| < RSIGNEDSHIFTASSIGN: ">>=" > : DEFAULT
| < RUNSIGNEDSHIFTASSIGN: ">>>=" > : DEFAULT
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/**
 * Main entry point of the parser.  This rule parses an entire
 * JavaScript program.
 */
void parse() :
{
    Token t;
}
{                      { m_handler.handleStart(); }
    ( <UNICODE_BOM> )?
    ( W() )*
    ( Element() )*
    (
      t=<CDC>          { m_handler.handleCDC(t.image); } ( W() )*
      |
      t=<CRIPPLED_SINGLE_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.CRIPPLED_SINGLE_LINE_COMMENT); }
    )?
    <EOF>              { m_handler.handleFinish(); }
}


void W() :
    {
    Token t;
    }
    { t=<S>            { m_handler.handleWhite    (t.image); }
    | t=<L>            { m_handler.handleEndOfLine(t.image); }
    | t=<SINGLE_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.SINGLE_LINE_COMMENT); }
    | t=<MULTI_LINE_COMMENT>
                       { m_handler.handleComment(t.image,
                          m_handler.MULTI_LINE_COMMENT); }
    | <JAVA_CODE> 
    }


void Element() :
{
    Token t, t1;
}
{
    ( Function() | Statement() )
}

void Function() :
{
    Token t;
}
{
    // CvdL: JScript can have "function document.onReadStateChange() {}"
      t=<FUNCTION>     { m_handler.handleKeyword(t.image);  } ( W() )*

      // function literal doesn't take name
      (
          t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
          (
              t="."          { m_handler.handleOperator(t.image); } ( W() )*
              t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
          )*
      )?
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      ( ParameterList() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      CompoundStatement()
}


void ParameterList() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image);  } ( W() )*
    (
      t=","            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
    )*
}

void CompoundStatement() :
{
    Token t;
}
{
    t="{"              { m_handler.handleOperator(t.image); } ( W() )*
    // support nested function
    ( Element() )*
    t="}"              { m_handler.handleOperator(t.image); } ( W() )*
}


void Statement() :
{
    Token t;
}
{
    (
      /* empty statement */
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    |
      /* labeled statement */
      LOOKAHEAD( <IDENTIFIER> ( W() )* ":" )
      t=<IDENTIFIER>   { m_handler.handleLiteral (t.image); } ( W() )*
      t=":"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<IF>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      Statement()
      ( LOOKAHEAD(1)
        t=<ELSE>       { m_handler.handleKeyword(t.image);  } ( W() )*
        Statement()
      )?
    |
      t=<WHILE>        { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      Statement()
    |
      t=<DO>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Statement()
      t=<WHILE>        { m_handler.handleKeyword(t.image);  } ( W() )*
      Condition()
      // semicolon!!
    |
      LOOKAHEAD( <FOR> (W())* "(" (W())* ";" )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      LOOKAHEAD( <FOR> (W())* "(" (W())* VariablesOrExpression() ";" )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      VariablesOrExpression()
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      ( Expression() )?
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      LOOKAHEAD (<FOR> (W())* "(" (W())* (<VAR> (W())*)? <IDENTIFIER> (W())* <IN> )
      t=<FOR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      (
        t=<VAR>        { m_handler.handleKeyword(t.image);  } ( W() )*
      )?
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
      t=<IN>           { m_handler.handleKeyword(t.image);  } ( W() )*
      Expression()
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<WITH>         { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      Statement()
    |
      t=<TRY>          { m_handler.handleKeyword(t.image);  } ( W() )*
      CompoundStatement()
      t=<CATCH>        { m_handler.handleKeyword(t.image);  } ( W() )*
      t="("            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } ( W() )*
      t=")"            { m_handler.handleOperator(t.image); } ( W() )*
      CompoundStatement()
      (
        t=<FINALLY>    { m_handler.handleKeyword(t.image);  } ( W() )*
        CompoundStatement()
      )?
    |
      t=<THROW>        { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      (
        t=";"          { m_handler.handleOperator(t.image); } ( W() )*
      )?
    |
      t=<BREAK>        { m_handler.handleKeyword(t.image);  } ( W() )*
      (
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
      )?
      (
        t=";"          { m_handler.handleOperator(t.image); } ( W() )*
      )?
    |
      t=<CONTINUE>     { m_handler.handleKeyword(t.image);  } ( W() )*
      (
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image);  } ( W() )*
      )?
      (
        t=";"          { m_handler.handleOperator(t.image); } ( W() )*
      )?
    |
      t=<RETURN>       { m_handler.handleKeyword(t.image);  } ( W() )*
      ( Expression() )?
      ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      )?
    |
      SwitchStatement()
    |
      CompoundStatement()
    |
      VariablesOrExpression()
      ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
      )?
    )
}

void SwitchStatement() :
{
    Token t;
}
{
    t=<SWITCH>         { m_handler.handleKeyword(t.image);  } ( W() )*
    t="("              { m_handler.handleOperator(t.image); } ( W() )*
    Expression()
    t=")"              { m_handler.handleOperator(t.image); } ( W() )*
    t="{"              { m_handler.handleOperator(t.image); } ( W() )*
    (
      CaseLabel()
    | CaseDefaultLabel()
    )*
    t="}"              { m_handler.handleOperator(t.image); } ( W() )*
}

void CaseLabel() :
{
    Token t;
}
{
    t=<CASE>           { m_handler.handleKeyword(t.image);  } ( W() )*
    Expression()
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    ( LOOKAHEAD(1)
      Statement()
    )*
    ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    )?
}

void CaseDefaultLabel() :
{
    Token t;
}
{
    t=<_DEFAULT>       { m_handler.handleKeyword(t.image);  } ( W() )*
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    ( LOOKAHEAD(1)
      Statement()
    )*
    ( LOOKAHEAD(1)
      t=";"            { m_handler.handleOperator(t.image); } ( W() )*
    )?
}

void Condition() :
{
    Token t;
}
{
    t="("              { m_handler.handleOperator(t.image); } ( W() )*
    Expression()
    t=")"              { m_handler.handleOperator(t.image); } ( W() )*
}

// ### Check up on the semantics of this - not sure whether it should
// be statement or expression
void VariablesOrExpression() :
{
    Token t;
}
{
    (
      t=<VAR>          { m_handler.handleKeyword(t.image);  } ( W() )*
      Variables()
    |
      Expression()
  )
}

void Variables() :
{
    Token t;
}
{
  Variable() ( W() )*
  (
    t=","              { m_handler.handleOperator(t.image); } ( W() )*
    Variable()
  )*
}

void Variable() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image);  }
    ( LOOKAHEAD(1) W() )*
    (
      t="="            { m_handler.handleOperator(t.image); } ( W() )*
      AssignmentExpression()
    )?
}

void Expression() :
{
    Token t;
}
{
  AssignmentExpression() ( W() )*
  (
    t=","              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
  )*
}

void AssignmentExpression() :
{
    Token t;
}
{
  ConditionalExpression()
  (
    LOOKAHEAD(1)
    ( t="=" | t="&&=" | t="||=" | t="+=" | t="-=" | t="*=" | t="/=" |
      t="&=" | t="|=" | t="^=" | t="%=" | t="<<=" | t=">>=" | t=">>>=" )
    {
        m_handler.handleOperator(t.image);
    }
    ( W() )*
    ConditionalExpression()
  )*
}

void ConditionalExpression() :
{
    Token t;
}
{
  OrExpression()
  (
    t="?"              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
    t=":"              { m_handler.handleOperator(t.image); } ( W() )*
    AssignmentExpression()
  )?
}

void OrExpression() :
{
    Token t;
}
{
    AndExpression()
    (
      t="||"           { m_handler.handleOperator(t.image); } ( W() )*
      AndExpression()
    )*
}

void AndExpression() :
{
    Token t;
}
{
    BitwiseOrExpression()
    (
      t="&&"           { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseOrExpression()
    )*
}

void BitwiseOrExpression() :
{
    Token t;
}
{
    BitwiseXorExpression()
    (
      t="|"            { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseXorExpression()
    )*
}

void BitwiseXorExpression() :
{
    Token t;
}
{
    BitwiseAndExpression()
    (
      t="^"            { m_handler.handleOperator(t.image); } ( W() )*
      BitwiseAndExpression()
    )*
}

void BitwiseAndExpression() :
{
    Token t;
}
{
    EqualityExpression()
    (
      t="&"            { m_handler.handleOperator(t.image); } ( W() )*
      EqualityExpression()
    )*
}

void EqualityExpression() :
{
    Token t;
}
{
    InstanceOfExpression()
    (
      // the "in" operator is treated like a boolean comparison operator
      LOOKAHEAD(1)
      (
        ( t="==" | t="!=" | t="===" | t="!==" )
          {
          m_handler.handleOperator(t.image);
          }
        |
          t="in"
          {
          m_handler.handleKeyword(t.image);
          }
        )
      ( W() )* InstanceOfExpression()
    )*
}

// this routine is mirrored after the Java1.1 grammar.
void InstanceOfExpression() :
{
    Token t;
}
{
    RelationalExpression()
      (
        t="instanceof"
        {
        m_handler.handleKeyword(t.image);
        }
        // here comes actually a type expression
        ( W() )* MemberExpression()
      )?
}

void RelationalExpression() :
{
    Token t;
}
{
    ShiftExpression()
    (
      ( t="<" | t=">" | t="<=" | t=">=" )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* ShiftExpression()
    )*
}

void ShiftExpression() :
{
    Token t;
}
{
    AdditiveExpression()
    (
      ( t="<<" | t=">>" | t=">>>" )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* AdditiveExpression()
    )*
}

void AdditiveExpression() :
{
    Token t;
}
{
    MultiplicativeExpression()
    (
      LOOKAHEAD(1)
      ( t="+" | t="-" )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* MultiplicativeExpression()
    )*
}

void MultiplicativeExpression() :
{
    Token t;
}
{
    UnaryExpression()
    (
      ( t="*" | t="/" | t="%" )
        {
        m_handler.handleOperator(t.image);
        }
      ( W() )* UnaryExpression()
    )*
}

void UnaryExpression() :
{
    Token t;
}
{
    (
      ( t="!" | t="~" )   { m_handler.handleOperator(t.image); } ( W() )*
      UnaryExpression() 
    |
      t="-"               { m_handler.handleOperator(t.image); } ( W() )*
      UnaryExpression() 
    |
      LOOKAHEAD(1)
      ( t="++" | t="--" ) { m_handler.handleOperator(t.image); } ( W() )*
      MemberExpression() 
    |
      MemberExpression() 
      (
        LOOKAHEAD(1)
        ( t="++" | t="--" ) { m_handler.handleOperator(t.image); }
        ( LOOKAHEAD(1) W() )*
      )?
    |
      /* NEW is not really a unary expression
      t=<NEW>               { m_handler.handleKeyword(t.image); } ( W() )*
      Constructor() 
    |
      */
      t=<DELETE>            { m_handler.handleKeyword(t.image); } ( W() )*
      MemberExpression()   /* should be UnaryExpression() */
    |
      t=<VOID>              { m_handler.handleKeyword(t.image); } ( W() )*
      UnaryExpression() 
    |
      t=<TYPEOF>            { m_handler.handleKeyword(t.image); } ( W() )*
      MemberExpression()    /* should be UnaryExpression() */
    )
}

void Constructor() :
{
}
{
    ConstructorCall()
}

void ConstructorCall() :
{
    Token t;
}
{
    t=<IDENTIFIER>     { m_handler.handleLiteral(t.image); }
    ( LOOKAHEAD(1) W() )*
    (
      t="."            { m_handler.handleOperator(t.image); } ( W() )*
      t=<IDENTIFIER>   { m_handler.handleLiteral(t.image); }
      ( LOOKAHEAD(1) W() )*
    )*
    (
      LOOKAHEAD(1)
      t="("            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
      ( ArgumentList() )?
      t=")"            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
    )?
}

// Departs from the grammar in the standard, since this works in all browsers
void MemberExpression() :
{
    Token t;
}
{
    PrimaryExpression()
    (
      t="."            { m_handler.handleOperator(t.image); } ( W() )*
      PrimaryExpression()
    |
      t="+"            { m_handler.handleOperator(t.image); } ( W() )*
      PrimaryExpression()
    |
      t="["            { m_handler.handleOperator(t.image); } ( W() )*
      Expression()
      t="]"            { m_handler.handleOperator(t.image); }
      ( LOOKAHEAD(1) W() )*
    |
      t="("            { m_handler.handleOperator(t.image); m_handler.handleFunctionStart(t.image);} ( W() )*
      ( ArgumentList() )?
      t=")"            { m_handler.handleOperator(t.image); m_handler.handleFunctionEnd(t.image);}
      ( LOOKAHEAD(1) W() )*
    )*
}

// Vector of JSExpressions
void ArgumentList() :
{
    Token t;
}
{
    AssignmentExpression()
    (
      t=","            { m_handler.handleOperator(t.image); } ( W() )*
      AssignmentExpression()
    )*
}

void PrimaryExpression() :
{
    Token t;
}
{
  (
    t="(" {m_handler.handleOperator(t.image);}
    ( W() )*
    Expression()
    t=")" {m_handler.handleOperator(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
    t=<IDENTIFIER> {m_handler.handleLiteral(t.image); m_handler.handlerFunctionName(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
    t=<INTEGER_LITERAL> {m_handler.handleLiteral(t.image); }
    ( LOOKAHEAD(1) W() )*
  |
    t=<MINUS> {m_handler.handleLiteral(t.image); }
    ( W() )*
    t=<INTEGER_LITERAL> {m_handler.handleLiteral(t.image); }
    ( LOOKAHEAD(1) W() )*
  |
    t=<FLOATING_POINT_LITERAL> {m_handler.handleLiteral(t.image); }
    ( LOOKAHEAD(1) W() )*
  |
    t=<STRING_LITERAL> {m_handler.handleString(t.image); }
    ( LOOKAHEAD(1) W() )*
  |
    t=<REGEXP_LITERAL> {m_handler.handleLiteral(t.image); }
    (LOOKAHEAD(1) W() )*
  |
    t=<BOOLEAN_LITERAL> {m_handler.handleLiteral(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
    t=<NULL_LITERAL> {m_handler.handleLiteral(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
    // Fri Nov 15 00:53:43 2002 CF Hack: allow #var# inside Javascript.
    t=<CF_VARIABLE> {m_handler.handleLiteral(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
    t=<THIS> {m_handler.handleLiteral(t.image);}
    ( LOOKAHEAD(1) W() )*
  |
      t=<NEW> {m_handler.handleKeyword(t.image);}
    ( LOOKAHEAD(1) W() )*
    Constructor()
  |
    ArrayLiteral()
  |
    ObjectLiteral() 
  |
    // support function literal (anonymous function) 
    Function() 
  )
}

// myHonda = {color:"red",wheels:4,engine:{cylinders:4,size:2.2}};
// CvdL: not used yet - creates ambiguities and must be placed
// only in an assignment context
void ObjectLiteral() :
{
    Token t;
}
{
    t="{"               { m_handler.handleOperator(t.image); } (W())*
    (
      ObjectLiteralItem()
      (
        t=","            { m_handler.handleOperator(t.image); } (W())*
        ObjectLiteralItem()
      )*
    )?
    t="}"                { m_handler.handleOperator(t.image); }
    (LOOKAHEAD(1) W())*
}

void ObjectLiteralItem() :
{
    Token t;
}
{
      (
        t=<IDENTIFIER>    { m_handler.handleLiteral(t.image);  } (W())*
        |
        t=<STRING_LITERAL>
                        { m_handler.handleString(t.image);   } (W())*
      )
      t=":"             { m_handler.handleOperator(t.image); } (W())*
      (
        MemberExpression()       
      )
}

// var aArray = [ ,, , "1", 2, new X(), ];
void ArrayLiteral() :
{
    Token t;
}
{
    t="["
        {
        m_handler.handleOperator(t.image);
        }
    ( LOOKAHEAD(1) W() )*
    (
      (
      t=","
        {
        m_handler.handleOperator(t.image);
        }
      ( LOOKAHEAD(1) W() )*
      )*

      AssignmentExpression()
      ( LOOKAHEAD(1) W() )*
      ( LOOKAHEAD(1)
      t=","
        {
        m_handler.handleOperator(t.image);
        }
      ( LOOKAHEAD(1) W() )*
      )*
    )*
    t="]"
        {
        m_handler.handleOperator(t.image);
        }
    ( LOOKAHEAD(1) W() )*
}

