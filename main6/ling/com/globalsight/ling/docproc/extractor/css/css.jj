//                              -*- Mode: Java -*-
/*
 * Copyright (c) 2000 GlobalSight Corporation. All rights reserved.
 *
 * THIS DOCUMENT CONTAINS TRADE SECRET DATA WHICH IS THE PROPERTY OF
 * GLOBALSIGHT CORPORATION. THIS DOCUMENT IS SUBMITTED TO RECIPIENT
 * IN CONFIDENCE. INFORMATION CONTAINED HEREIN MAY NOT BE USED, COPIED
 * OR DISCLOSED IN WHOLE OR IN PART EXCEPT AS PERMITTED BY WRITTEN
 * AGREEMENT SIGNED BY AN OFFICER OF GLOBALSIGHT CORPORATION.
 *
 * THIS MATERIAL IS ALSO COPYRIGHTED AS AN UNPUBLISHED WORK UNDER
 * SECTIONS 104 AND 408 OF TITLE 17 OF THE UNITED STATES CODE.
 * UNAUTHORIZED USE, COPYING OR OTHER REPRODUCTION IS PROHIBITED
 * BY LAW.
 */

options
    {
    STATIC = false;
    LOOKAHEAD = 1;
    DEBUG_PARSER = false;
    UNICODE_INPUT = true;
    IGNORE_CASE = true;
    }

PARSER_BEGIN(Parser)
package com.globalsight.ling.docproc.extractor.css;

/**
 * A CSS Parser automatically generated by JavaCC.  Fires {@link
 * com.globalsight.ling.docproc.extractor.css.IParseEvents
 * IParseEvents}.
 */
public class Parser
{
    private IParseEvents m_handler = null;

    public void setHandler(IParseEvents p_handler)
    {
        m_handler = p_handler;
    }
}
PARSER_END(Parser)


/*****************************************
 * LEXICAL RULES
 *****************************************/

TOKEN : /* WHITE SPACE - \u001a is ^Z */
{
  <S: (" " | "\t" | "\f" | "\u001a")+ >
|
  <L: ("\n" | "\r" | "\r\n")+ >
|
  <UNICODE_BOM: ("\uFEFF"|"\uFFFE") >
}

TOKEN : /* COMMENTS, C-Style */
{
  <C: ("/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/") | "<!--" (~[">"]|(~["-"] ("-")? ">"))* "-->">
}

TOKEN : /* STANDARD LITERALS */
{
  <DIMENSION:  <NUMBER> <IDENT> >
| <PERCENTAGE: <NUMBER> "%" >
| <NUMBER: ((<DIGIT>)+ | (<DIGIT>)* "." (<DIGIT>)+ ) >
| // Highest unicode code point is \u10ffff, but JavaCC doesn't recognize it.
  // We have to limit the code range in BMP.
  <STRING:
        "\""
        (
          [" ","\t","!","#","$","%","&","'","("-"~","\u0080"-"\uffff"]
        | "\\" ( "\n" | "\r" | "\r\n" | "\f" )
        | <ESCAPE>
        )*
        "\""
      | "'"
        (
          [" ","\t","!","#","$","%","&","\"","("-"~","\u0080"-"\uffff"]
        | "\\" ( "\n" | "\r" | "\r\n" | "\f" )
        | <ESCAPE>
        )*
        "'"
  >
| <IDENT: (<NMSTART>|<ESCAPE>) (<NMCHAR>|<DIGIT>|<ESCAPE>)* >
| <#NMSTART: ["a"-"z","\u0080"-"\uffff"] >
| <#NMCHAR:  ["a"-"z","-","\u0080"-"\uffff"] >
| <#DIGIT:   ["0"-"9"] >
| // The unicode escape is crazy.  Who wrote this standard? See CSS2 4.1.3.
  <#ESCAPE:
      "\\" (
             [" "-"~","\u0080"-"\uffff"]
           |
             (["0"-"9","a"-"f"])+ ([" ","\t","\n","\r","\f"])?
           )
  >
| // U+h{1-6}-h{1-6}, so we overgenerate. "?" is a wildcard.
  <UNICODERANGE:
    "U+" ( ["0"-"9","a"-"f","?"] )+ ( "-" ( ["0"-"9","a"-"f","?"] )+ )? >
| // #id and colors of the form #hhh and #hhhhhh
  <HASH: "#" (<NMCHAR>|<DIGIT>|<ESCAPE>)* >
| <FUNCTION: <IDENT> "(" >
| <URI: "url(" (<S>|<L>)?
               (
                 <STRING>
               |
                 (
                   ["!","#","$","%","&","*"-"~","\u0080"-"\uffff"]
                 |
                   <ESCAPE>
                 )*
               )
               (<S>|<L>)? ")"
  >
| <RGB: "rgb(" (<S>|<L>)?
               ("-")? (["0"-"9"])+ ("%")? (<S>|<L>)? "," (<S>|<L>)?
               ("-")? (["0"-"9"])+ ("%")? (<S>|<L>)? "," (<S>|<L>)?
               ("-")? (["0"-"9"])+ ("%")? (<S>|<L>)?
               ")"
  >
 // number, percent, dimension, "auto": rect(-1 2% 3px auto)
 // MS Office outputs this with commas - against the standard.
| <RECT: "rect(" (<S>|<L>)?
                 ("-")? ( <NUMBER> ("%" | <STRING>)? | "auto" )
                 (<S>|<L>)? ("," (<S>|<L>)? )?
                 ("-")? ( <NUMBER> ("%" | <STRING>)? | "auto" )
                 (<S>|<L>)? ("," (<S>|<L>)? )?
                 ("-")? ( <NUMBER> ("%" | <STRING>)? | "auto" )
                 (<S>|<L>)? ("," (<S>|<L>)? )?
                 ("-")? ( <NUMBER> ("%" | <STRING>)? | "auto" )
                 (<S>|<L>)? ")"
  >
}

TOKEN :
{
  < CHARSET:   "@charset" >
| < FONTFACE:  "@font-face" >
| < IMPORT:    "@import" >
| < MEDIA:     "@media" >
| < ATKEYWORD: "@" <IDENT> >
}


TOKEN : /* SEPARATORS */
{ <LPAREN: "(" >
| <RPAREN: ")" >
| <LBRACE: "{" >
| <RBRACE: "}" >
| <LBRACKET: "[" >
| <RBRACKET: "]" >
| <COLON: ":" >
| <SEMICOLON: ";" >
| <INCLUDES: "~=" >
| <DASHMATCH: "|=" >
| <COMMA: "," >                                   // need that for @rules
}

TOKEN : /* SGML SEPARATORS */
{
  <CDO: "<!--">
| <CDC: "--" (<S>)? ">">
}

TOKEN : /* everything else */
{
  <DELIM : ~[]>
}

/*****************************************
 * SYNTATIC RULES
 *****************************************/

/**
 * Main entry point of the parser.  This rule parses an entire CSS
 * style sheet.
 */
void Parse() :
    {
    Token t;
    }
    {                  { m_handler.handleStart(); }
    ( <UNICODE_BOM> )?
    ( t=<CDO>          { m_handler.handleCDO(t.image); }
    | t=<CDC>          { m_handler.handleCDC(t.image); }
    | Statement()
    | LOOKAHEAD(1) W()
    )*
    <EOF>              { m_handler.handleFinish(); }
    }


void W() :
    {
    Token t;
    }
    { t=<S>            { m_handler.handleWhite  (t.image); }
    | t=<C>            { m_handler.handleComment(t.image); }
    | t=<L>            { m_handler.handleEndOfLine(t.image); }
    }


void Statement() :
    {
    }
    {
      Ruleset()
    | AtRule()
    | CharSet()                                   // these are special @rules
    | FontFace()
    | Import()
    | Media()
    }

// handle some @keywords and leave the general AtRule() for unknown stuff
void CharSet() :
{
    Token t;
}
    {
    t="@charset"       { m_handler.handleStartCharset(t.image); }
    ( W() )*
    t=<STRING>         { m_handler.handleCharset(t.image); }
    ( W() )*
    t=";"              { m_handler.handleEndCharset(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void Import() :
{
    Token t;
}
    {
    t="@import"        { m_handler.handleStartImport(t.image); }
    ( W() )*
    ( t=<STRING>       { m_handler.handleImport(t.image); }
    | t=<URI>          { m_handler.handleImportURI(t.image); }
    )
    ( W() )*
    ( t=<IDENT>        { m_handler.handleMedia(t.image); }
      ( W() )*
      ( t=","          { m_handler.handleDelimiter(t.image); }
        ( W() )*
        t=<IDENT>      { m_handler.handleMedia(t.image); }
        ( W() )*
      )*
    )?
    t=";"              { m_handler.handleEndImport(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void FontFace() :
{
    Token t;
}
    {
    t="@font-face"     { m_handler.handleStartFontFace(t.image); }
    ( W() )*
    t="{"              { m_handler.handleDelimiter(t.image); }
    ( W() )*
    /*BUG: ( Ruleset() )* */
    OptionalDeclarationList()
    t="}"              { m_handler.handleEndFontFace(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void Media() :
{
    Token t;
}
    {
    t="@media"          { m_handler.handleStartMedia(t.image); }
    ( W() )*
    t=<IDENT>           { m_handler.handleMedia(t.image); }
    ( W() )*
    ( t=","             { m_handler.handleDelimiter(t.image); }
      ( W() )*
      t=<IDENT>         { m_handler.handleMedia(t.image); }
      ( W() )*
    )*
    t="{"               { m_handler.handleDelimiter(t.image); }
    ( W() )*
    ( Ruleset() | AtRule() )*
    t="}"               { m_handler.handleEndMedia(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void AtRule() :
    {
    Token t;
    }
    {
    t=<ATKEYWORD>      { m_handler.handleStartAtRule(t.image); }
    ( LOOKAHEAD(1) W() )*
    ( LOOKAHEAD(1) Any() )*
    (
      t="{"              { m_handler.handleStartDeclarations(t.image); }
      ( LOOKAHEAD(1) W() )*
      OptionalDeclarationList()
      t="}"              { m_handler.handleEndDeclarations(t.image); }
      ( LOOKAHEAD(1) W() )*
    | t=";"            { m_handler.handleDelimiter(t.image); }
      ( LOOKAHEAD(1) W() )*
    )?
    }


void Block() :
    {
    Token t;
    }
    {
    t="{"              { m_handler.handleStartBlock(t.image); }
    ( LOOKAHEAD(1) W() )*
    (
      Any()
    | Block()
    | t=<ATKEYWORD>    { m_handler.handleStartAtRule(t.image); }
      ( LOOKAHEAD(1) W() )*
    | t=";"            { m_handler.handleDelimiter(t.image); }
      ( LOOKAHEAD(1) W() )*
    )*
    t="}"              { m_handler.handleEndBlock(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void Ruleset() :
    {
    Token t;
    }
    {
    ( Selector() )?
    t="{"              { m_handler.handleStartDeclarations(t.image); }
    ( LOOKAHEAD(1) W() )*
    OptionalDeclarationList()
    t="}"              { m_handler.handleEndDeclarations(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void OptionalDeclarationList() :
    {
    Token t;
    }
    {
    ( Declaration() )?
    ( t=";"            { m_handler.handleDelimiter(t.image); }
      ( LOOKAHEAD(1) W() )*
      ( Declaration()
      )?
    )*
    }


/**
 * Second entry point to parse styles inside the STYLE attribute.  We
 * allow for an optional Unicode byte order mark at the beginning of
 * the input.
 */
void DeclarationList() :
    {
    Token t;
    }
    {
    ( <UNICODE_BOM> )?
    ( LOOKAHEAD(1) W() )*
    Declaration()
    ( t=";"            { m_handler.handleDelimiter(t.image); }
      ( LOOKAHEAD(1) W() )*
      ( Declaration()
      )?
    )*
    }


void Selector() :
    {
    }
    {
    ( Any() )+
    }


void Declaration() :
    {
    Token t;
    }
    {
    StyleName()
    t=":"              { m_handler.handleStartValues(t.image); }
    ( LOOKAHEAD(1) W() )*
    StyleValue()       { m_handler.handleEndValues(); }
    }


void StyleName() :
    {
    Token t;
    }
    {
    t=<IDENT>          { m_handler.handleStyle(t.image); }
    ( LOOKAHEAD(1) W() )*
    }


void StyleValue() :
    {
    Token t;
    }
    {
    ( Any()
    | Block()
    | t=<ATKEYWORD>    { m_handler.handleStartAtRule(t.image); }
      ( LOOKAHEAD(1) W() )*
    )+
    }


void Any() :
    {
    Token t;
    }
    {
    ( t=<IDENT>        { m_handler.handleToken(t.image); }
    | t=<NUMBER>       { m_handler.handleToken(t.image); }
    | t=<PERCENTAGE>   { m_handler.handleToken(t.image); }
    | t=<DIMENSION>    { m_handler.handleToken(t.image); }
    | t=<STRING>       { m_handler.handleToken(t.image); }
    | t=<DELIM>        { m_handler.handleDelimiter(t.image); }
    | t=","            { m_handler.handleDelimiter(t.image); }
    | t=":"            { m_handler.handleDelimiter(t.image); }
    | t=<URI>          { m_handler.handleFunction(t.image); }
    | t=<RGB>          { m_handler.handleFunction(t.image); }
    | t=<RECT>         { m_handler.handleFunction(t.image); }
    | t=<HASH>         { m_handler.handleToken(t.image); }
    | t=<UNICODERANGE> { m_handler.handleToken(t.image); }
    | t=<INCLUDES>     { m_handler.handleDelimiter(t.image); }
    | t=<DASHMATCH>    { m_handler.handleDelimiter(t.image); }
    | t=<FUNCTION>     { m_handler.handleFunction(t.image); }
      ( W() | Any() )*
      t=")"            { m_handler.handleDelimiter(t.image); }
    | t="("            { m_handler.handleDelimiter(t.image); }
      ( W() | Any() )*
      t=")"            { m_handler.handleDelimiter(t.image); }
    | t="["            { m_handler.handleDelimiter(t.image); }
      ( W() | Any() )*
      t="]"            { m_handler.handleDelimiter(t.image); }
    )
    ( LOOKAHEAD(1) W() )*
    }

