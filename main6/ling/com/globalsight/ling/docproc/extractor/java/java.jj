/** -*- Mode: Java -*-
 * This file is a modified version of one originally found in the
 * JavaGrammars Examples directory of JavaCC1_1. It has been
 * modified to accept Java source code for Java 1.2. Basically,
 * this means a new key word was added, 'strictfp', and that keyword
 * added to the appropriate productions and LOOKAHEADs (where other,
 * similar keywords are listed as possible choices). This involved
 * changing 11 lines.
 *
 * Minor changes were also made to the main program for testing.
 *
 * The goal of this effort was for the grammar to be able to parse
 * any legal Java 1.2 source code. It does not reject all illegal
 * cases, but neither did the original. Plus, when it comes to
 * the new 'strictfp' keyword, the Java Compiler from Sun (JDK1.2.1)
 * also does not reject all illegal cases, as defined by the
 * "Updates" document found at
 *       http://java.sun.com/docs/books/jls/strictfp-changes.pdf
 * (see the testcases.txt file for details).
 *
 * David Williams, 7/99
 * ===================================================================
 *
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */

options {
  STATIC = false;
  DEBUG_PARSER = false;
  UNICODE_INPUT = true;                           // !!
  JAVA_UNICODE_ESCAPE = true;                    // !!
  //DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)
package com.globalsight.ling.docproc.extractor.java;

public class Parser
{
    private IParseEvents m_handler = null;

    public void setHandler(IParseEvents handler)
    {
        m_handler = handler;
    }

    private void appendToken(Token t1, String s, Token t2)
    {
        t1.image = t1.image + ((s != null) ? s : "") + t2.image;
        t1.endLine = t2.endLine;
        t1.endColumn = t2.endColumn;
        t1.next = t2.next;
    }

    // modified main. DW, 7/99
    public static void main (String [] args) {
        Parser parser;
        String filename = null;
        long initTime = 0;
        long parseTime = 0;
        long startTime = 0;
        long stopTime = 0;

        if (args.length == 0)
        {
            System.out.println("Java Parser Version 1.1 (for Java1.2 code):" +
              "  Reading from standard input . . .");
            parser = new Parser(System.in);
        }
        else if (args.length == 1)
        {
            filename = args[0];
            System.out.println("Java Parser Version 1.1 (for Java1.2 code):" +
              "  Reading from file " + filename + " . . .");
            try
            {
                startTime = System.currentTimeMillis();
                parser = new Parser(new java.io.FileInputStream(filename));
                stopTime = System.currentTimeMillis();
                initTime = stopTime - startTime;
            }
            catch (java.io.FileNotFoundException e)
            {
                System.out.println("Java Parser Version 1.1 (for Java1.2 code):" +
                  "  File " + filename + " not found.");
                return;
            }
        }
        else
        {
            System.out.println("Java Parser Version 1.1 (for Java1.2 code):" +
              "  Usage is one of:");
            System.out.println("         java Parser < inputfile");
            System.out.println("OR");
            System.out.println("         java Parser inputfile");
            return;
        }
        try
        {
            startTime = System.currentTimeMillis();
            parser.CompilationUnit();
            stopTime = System.currentTimeMillis();
            parseTime = stopTime - startTime;
            System.out.println("Java Parser Version 1.1 (for Java1.2 code): ");
            System.out.println("   Java program parsed " + filename +
              " successfully in " + (initTime + parseTime) + " ms.");
            System.out.println("      parser initialization time was " +
              initTime + " ms.");
            System.out.println("      parser parse time was " +
              parseTime + " ms.");
        }
        catch (ParseException e)
        {
            System.out.println(e.getMessage());
            System.out.println("Java Parser Version 1.1 (for Java1.2 code):" +
              "  Encountered errors during parse.");
        }
    }

}

PARSER_END(Parser)


/* WHITE SPACE - \u001a=^Z */

TOKEN :
{
    <S: (" " | "\t" | "\n" | "\r" | "\f" | "\u001a" | "\uFEFF" | "\uFFFE")+ >
}

/* COMMENTS */

TOKEN :
{
  // IE handles "<!--" like "//" and does not expect a closing "-->".
  // <SCRIPT><!-- alert(1); --></SCRIPT> is *NOT* executed.
  <SINGLE_LINE_COMMENT:
    "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
|
  /* This one can only occur immediately before EOF */
  <CRIPPLED_SINGLE_LINE_COMMENT:
    // "//" (~["\n","\r"])* ( <CDC> (~["\n","\r"])* )? >
    "//" (~["\n","\r"])* >
|
  <MULTI_LINE_COMMENT:
    "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < STRICTFP: "strictfp" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"      
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE EXTRACTOR ENTRY POINT STARTS HERE *
 *****************************************/

void parseFile() :
{
}
{
    (W())*
    CompilationUnit()
}


void parseStatements() :
{
    Token t;
}
{
    (W())*
    (
      BlockStatement()
    |
      LOOKAHEAD( "}" (W())* <ELSE> )
      t="}"             { m_handler.handleOperator(t.image); } (W())*
      t=<ELSE>          { m_handler.handleKeyword(t.image);  } (W())*
      Statement()
    |
      LOOKAHEAD( "}" (W())* <WHILE> (W())* "(" (W())* Expression() ")" (W())* ";" )

      t="}"             { m_handler.handleOperator(t.image); } (W())*
      t=<WHILE>         { m_handler.handleKeyword(t.image);  } (W())*
      t="("             { m_handler.handleOperator(t.image); } (W())*
      Expression()
      t=")"             { m_handler.handleOperator(t.image); } (W())*
      t=";"             { m_handler.handleOperator(t.image); } (W())*
    |
      LOOKAHEAD( "}" (W())* <CATCH> )
      t="}"             { m_handler.handleOperator(t.image); } (W())*
      t=<CATCH>         { m_handler.handleKeyword(t.image);  } (W())*
      t="("             { m_handler.handleOperator(t.image); } (W())*
      FormalParameter()
      t=")"             { m_handler.handleOperator(t.image); } (W())*
      Block()
      (
        t=<CATCH>         { m_handler.handleKeyword(t.image);  } (W())*
        t="("             { m_handler.handleOperator(t.image); } (W())*
        FormalParameter()
        t=")"             { m_handler.handleOperator(t.image); } (W())*
        Block()
      )*
      [
        t=<FINALLY>     { m_handler.handleKeyword(t.image);  } (W())*
        Block()
      ]
    |
      t="}"             { m_handler.handleOperator(t.image); } (W())*
    )*
    (t=<CRIPPLED_SINGLE_LINE_COMMENT>
                        { m_handler.handleComment(t.image,
                          m_handler.CRIPPLED_SINGLE_LINE_COMMENT); } )?
    <EOF>
}


void parseExpression() :
{
    Token t;
}
{
    (W())*
    Expression()
    (t=<CRIPPLED_SINGLE_LINE_COMMENT>
                        { m_handler.handleComment(t.image,
                          m_handler.CRIPPLED_SINGLE_LINE_COMMENT); } )?
    <EOF>
}


void parseClassLevel() :
{
    Token t;
}
{
    (W())*
    ( ClassBodyDeclaration() )*
    (t=<CRIPPLED_SINGLE_LINE_COMMENT>
                        { m_handler.handleComment(t.image,
                          m_handler.CRIPPLED_SINGLE_LINE_COMMENT); } )?
    <EOF>
}


void W() :
{
    Token t;
}
{
    t=<S>            { m_handler.handleWhite    (t.image); }
//| t=<L>            { m_handler.handleEndOfLine(t.image); }
  | t=<SINGLE_LINE_COMMENT>
                     { m_handler.handleComment(t.image,
                       m_handler.SINGLE_LINE_COMMENT); }
  | t=<MULTI_LINE_COMMENT>
                     { m_handler.handleComment(t.image,
                       m_handler.MULTI_LINE_COMMENT); }
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void CompilationUnit() :
{}
{
  [ PackageDeclaration() ]
  ( ImportDeclaration() )*
  ( TypeDeclaration() )*
  <EOF>
}

void PackageDeclaration() :
{
    Token t;
}
{
    t=<PACKAGE>                 { m_handler.handleKeyword(t.image);  } (W())*
    Name()
    t=";"                       { m_handler.handleOperator(t.image); } (W())*
}

void ImportDeclaration() :
{
    Token t;
}
{
    t=<IMPORT>                  { m_handler.handleKeyword(t.image); } (W())*
    Name()
    [
      t="."                     { m_handler.handleOperator(t.image); } (W())*
      t="*"                     { m_handler.handleOperator(t.image); } (W())*
    ]
    t=";"                       { m_handler.handleOperator(t.image); } (W())*
}

void TypeDeclaration() :
{
    Token t;
}
{
  LOOKAHEAD( ( ("abstract" | "final" | "public" | "strictfp") (W())* )* "class" )
  ClassDeclaration()
|
  InterfaceDeclaration()
|
  t=";"                       { m_handler.handleOperator(t.image); } (W())*
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration() :
{
    Token t;
}
{
  (
    (t="abstract" | t="final" | t="public" | t="strictfp")
                             { m_handler.handleKeyword(t.image); } (W())*
  )*
  UnmodifiedClassDeclaration()
}

void UnmodifiedClassDeclaration() :
{
    Token t;
}
{
    t=<CLASS>                  { m_handler.handleKeyword(t.image); } (W())*
    t=<IDENTIFIER>             { m_handler.handleLiteral(t.image); } (W())*
    [
      t=<EXTENDS>              { m_handler.handleKeyword(t.image); } (W())*
      Name()
    ]
    [
      t=<IMPLEMENTS>           { m_handler.handleKeyword(t.image); } (W())*
      NameList()
    ]
    ClassBody()
}

void ClassBody() :
{
    Token t;
}
{
    t="{"                      { m_handler.handleOperator(t.image); } (W())*
    ( ClassBodyDeclaration() )*
    t="}"                      { m_handler.handleOperator(t.image); } (W())*
}

void NestedClassDeclaration() :
{
    Token t;
}
{
  (
    (t="static" | t="abstract" | t="final" | t="public" |
     t="protected" | t="private" | t="strictfp")
                               { m_handler.handleKeyword(t.image); } (W())*
  )*
  UnmodifiedClassDeclaration()
}

void ClassBodyDeclaration() :
{
    Token t;
}
{
  LOOKAHEAD(3)
  Initializer()
|
  LOOKAHEAD( ( ("static" | "abstract" | "final" | "public" |
    "protected" | "private" | "strictfp") (W())* )* "class" )
  NestedClassDeclaration()
|
  LOOKAHEAD( ( ("static" | "abstract" | "final" | "public" |
    "protected" | "private" | "strictfp") (W())* )* "interface" )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( [ ("public" | "protected" | "private") (W())* ] Name() (W())* "(" )
  ConstructorDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{
    Token t;
}
{
  (
    ("public" | "protected" | "private" | "static" | "abstract" |
      "final" | "native" | "synchronized" | "strictfp")
    (W())*
  )*
  ResultType() (W())*
  <IDENTIFIER> (W())*
  "("
}

void InterfaceDeclaration() :
{
    Token t;
}
{
  (
    (t="abstract" | t="public" | t="strictfp")
          { m_handler.handleKeyword(t.image); }  (W())*
  )*
    UnmodifiedInterfaceDeclaration()
}

void NestedInterfaceDeclaration() :
{
    Token t;
}
{
  (
    (t="static" | t="abstract" | t="final" | t="public" |
     t="protected" | t="private" | t="strictfp")
          { m_handler.handleKeyword(t.image); }  (W())*
  )*
  UnmodifiedInterfaceDeclaration()
}

void UnmodifiedInterfaceDeclaration() :
{
    Token t;
}
{
    t=<INTERFACE>                  { m_handler.handleKeyword(t.image);  } (W())*
    t=<IDENTIFIER>                 { m_handler.handleLiteral(t.image);  } (W())*
    [
      t=<EXTENDS>                  { m_handler.handleKeyword(t.image);  } (W())*
      NameList()
    ]
    t="{"                          { m_handler.handleOperator(t.image); } (W())*
    ( InterfaceMemberDeclaration() )*
    t="}"                          { m_handler.handleOperator(t.image); } (W())*
}

void InterfaceMemberDeclaration() :
{
    Token t;
}
{
  LOOKAHEAD( (("static" | "abstract" | "final" | "public" | "protected" |
    "private" | "strictfp") (W())* )* "class" )
  NestedClassDeclaration()
|
  LOOKAHEAD( (("static" | "abstract" | "final" | "public" | "protected" |
    "private" | "strictfp") (W())* )* "interface" )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

void FieldDeclaration() :
{
    Token t;
}
{
    (
      (t="public" | t="protected" | t="private" | t="static" |
       t="final" | t="transient" | t="volatile")
                                  { m_handler.handleKeyword(t.image);  } (W())*
    )*
    Type()
    VariableDeclarator()
    (
      t=","                       { m_handler.handleOperator(t.image); } (W())*
      VariableDeclarator()
    )*
    t=";"                         { m_handler.handleOperator(t.image); } (W())*
}

void VariableDeclarator() :
{
    Token t;
}
{
  VariableDeclaratorId()
  [
    t="="                      { m_handler.handleOperator(t.image); } (W())*
    VariableInitializer()
  ]
}

void VariableDeclaratorId() :
{
    Token t;
}
{
  t=<IDENTIFIER>               { m_handler.handleLiteral(t.image);  } (W())*
  (
    t="["                      { m_handler.handleOperator(t.image); } (W())*
    t="]"                      { m_handler.handleOperator(t.image); } (W())*
  )*
}

void VariableInitializer() :
{
    Token t;
}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{
    Token t;
}
{
    t="{"                        { m_handler.handleOperator(t.image); } (W())*
    [
      VariableInitializer()
      ( LOOKAHEAD("," (W())* VariableInitializer())
        t=","                    { m_handler.handleOperator(t.image); } (W())*
        VariableInitializer()
      )*
    ]
    [
      t=","                      { m_handler.handleOperator(t.image); } (W())*
    ]
    t="}"                        { m_handler.handleOperator(t.image); } (W())*
}

void MethodDeclaration() :
{
    Token t;
}
{
  (
    (t="public" | t="protected" | t="private" |
     t="static" | t="abstract" | t="final" |
     t="native" | t="synchronized" | t="strictfp")
                                 { m_handler.handleKeyword(t.image); } (W())*
  )*
  ResultType() (W())*
  MethodDeclarator() (W())*
  [
    t=<THROWS>                   { m_handler.handleKeyword(t.image); } (W())*
    NameList() (W())*
  ]
  (
    Block()
    |
    t=";"                        { m_handler.handleOperator(t.image); }
  )
  (LOOKAHEAD(1) W())*
}

void MethodDeclarator() :
{
    Token t;
}
{
  t=<IDENTIFIER>                { m_handler.handleKeyword(t.image);  } (W())*
  FormalParameters()
  (
    t="["                       { m_handler.handleOperator(t.image); } (W())*
    t="]"                       { m_handler.handleOperator(t.image); } (W())*
  )*
}

void FormalParameters() :
{
    Token t;
}
{
    t="("                      { m_handler.handleOperator(t.image); } (W())*
    [
      FormalParameter()
      (
        t=","                  { m_handler.handleOperator(t.image); } (W())*
        FormalParameter()
      )*
    ]
    t=")"                      { m_handler.handleOperator(t.image); } (W())*
}

void FormalParameter() :
{
    Token t;
}
{
  [
    t="final"                 { m_handler.handleKeyword(t.image); } (W())*
  ]
  Type() VariableDeclaratorId()
}

void ConstructorDeclaration() :
{
    Token t;
}
{
  [
    (t="public" | t="protected" | t="private")
                              { m_handler.handleKeyword(t.image);  } (W())*
  ]
  t=<IDENTIFIER>              { m_handler.handleLiteral(t.image);  } (W())*

  FormalParameters()
  [
    t=<THROWS>                { m_handler.handleKeyword(t.image);  } (W())*
    NameList()
  ]
  t="{"                       { m_handler.handleOperator(t.image); } (W())*
    [ LOOKAHEAD(ExplicitConstructorInvocation())
      ExplicitConstructorInvocation()
    ]
    ( BlockStatement() )*
  t="}"                       { m_handler.handleOperator(t.image); } (W())*
}

void ExplicitConstructorInvocation() :
{
    Token t;
}
{
  LOOKAHEAD("this" (W())* Arguments() ";")
  t="this"                    { m_handler.handleKeyword(t.image);  } (W())*
  Arguments()
  t=";"                       { m_handler.handleOperator(t.image); } (W())*
|
  [ LOOKAHEAD(PrimaryExpression() ".")
    PrimaryExpression()
    t="."                     { m_handler.handleOperator(t.image); } (W())*
  ]
  t="super"                   { m_handler.handleKeyword(t.image);  } (W())*
  Arguments()
  t=";"                       { m_handler.handleOperator(t.image); } (W())*
}

void Initializer() :
{
    Token t;
}
{
  [
    t="static"               { m_handler.handleKeyword(t.image); } (W())*
  ]
  Block()
}

/*
 * Type, name and expression syntax follows.
 */

void Type():
{}
{
   LOOKAHEAD(3) ReferenceType()
 |
   PrimitiveType()
}

void ReferenceType():
{Token t;}
{
   PrimitiveType() {System.out.println("PrimitiveType");} (LOOKAHEAD(1) W())*
   (
        t="[" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
        t="]" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
   )+
  |
   ( ClassOrInterfaceType() ) (W())*
   (
        t="[" { m_handler.handleOperator(t.image); } (W())*
        t="]" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
   )*
}

void ClassOrInterfaceType():
{Token t;}
{
  t=<IDENTIFIER> { m_handler.handleLiteral(t.image); } (LOOKAHEAD(1) W())*
  [ LOOKAHEAD(3) TypeArguments() (LOOKAHEAD(1) W())* ] 
  ( LOOKAHEAD(3) 
      t="." { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
      t=<IDENTIFIER> { m_handler.handleLiteral(t.image); } (LOOKAHEAD(1) W())*
      [ LOOKAHEAD(3) TypeArguments() ]  (LOOKAHEAD(1) W())*
  )*
}

void TypeArguments():
{Token t;}
{
   t="<" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
   TypeArgument() (LOOKAHEAD(1) W())*
   (    
       t="," { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
       TypeArgument()  (LOOKAHEAD(1) W())*
   )* 
   t=">" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
}

void TypeArgument():
{Token t;}
{
   ReferenceType() (LOOKAHEAD(1) W())*
 |
   t="?" { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
   [ WildcardBounds() ]
}

void WildcardBounds():
{Token t;}
{
   t="extends" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
   ReferenceType() (LOOKAHEAD(1) W())*
 |
   t="super" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
   ReferenceType() (LOOKAHEAD(1) W())*
}


void PrimitiveType():
{Token t;}
{
  t="boolean" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="char" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="byte" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="short" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="int" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="long" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="float" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  t="double" { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
}

void ResultType() :
{
    Token t;
}
{
  t=<VOID>    { m_handler.handleKeyword(t.image); } (LOOKAHEAD(1) W())*
|
  Type()
}

void Name() :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
    Token t;
}
{
  t=<IDENTIFIER>     { m_handler.handleLiteral(t.image);  } (LOOKAHEAD(1) W())*
  ( LOOKAHEAD("." (W())* <IDENTIFIER>)
    t="."            { m_handler.handleOperator(t.image); } (LOOKAHEAD(1) W())*
    t=<IDENTIFIER>   { m_handler.handleLiteral(t.image);  } (LOOKAHEAD(1) W())*
  )*
}

void NameList() :
{
    Token t;
}
{
  Name()
  (
    t=","      { m_handler.handleOperator(t.image); } (W())*
    Name()
  )*
}


/*
 * Expression syntax follows.
 */

void Expression() :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
    Token t;
}
{
  ConditionalExpression()
  [
    AssignmentOperator() Expression()
  ]
}

void AssignmentOperator() :
{
    Token t;
}
{
    (
      t="=" | t="*=" | t="/=" | t="%=" | t="+=" | t="-=" |
      t="<<=" | t=">>=" | t=">>>=" | t="&=" | t="^=" | t="|="
    )
      { m_handler.handleOperator(t.image); } (W())*
}

void ConditionalExpression() :
{
    Token t;
}
{
  ConditionalOrExpression()
  [
    t="?"                    { m_handler.handleOperator(t.image); } (W())*
    Expression()
    t=":"                    { m_handler.handleOperator(t.image); } (W())*
    ConditionalExpression()
  ]
}

void ConditionalOrExpression() :
{
    Token t;
}
{
  ConditionalAndExpression()
  (
    t="||"                     { m_handler.handleOperator(t.image); } (W())*
    ConditionalAndExpression()
  )*
}

void ConditionalAndExpression() :
{
    Token t;
}
{
  InclusiveOrExpression()
  (
    t="&&"                     { m_handler.handleOperator(t.image); } (W())*
    InclusiveOrExpression()
  )*
}

void InclusiveOrExpression() :
{
    Token t;
}
{
  ExclusiveOrExpression()
  (
    t="|"                      { m_handler.handleOperator(t.image); } (W())*
    ExclusiveOrExpression()
  )*
}

void ExclusiveOrExpression() :
{
    Token t;
}
{
  AndExpression()
  (
    t="^"                      { m_handler.handleOperator(t.image); } (W())*
    AndExpression()
  )*
}

void AndExpression() :
{
    Token t;
}
{
  EqualityExpression()
  (
    t="&"                      { m_handler.handleOperator(t.image); } (W())*
    EqualityExpression()
  )*
}

void EqualityExpression() :
{
    Token t;
}
{
  InstanceOfExpression()
  (
    ( t="==" | t="!=" )        { m_handler.handleOperator(t.image); } (W())*
    InstanceOfExpression()
  )*
}

void InstanceOfExpression() :
{
    Token t;
}
{
  RelationalExpression()
  [
    t=<INSTANCEOF>             { m_handler.handleKeyword(t.image); } (W())*
    Type()
  ]
}

void RelationalExpression() :
{
    Token t;
}
{
  ShiftExpression()
  (
    ( t="<" | t=">" |
      t="<=" | t=">=" )        { m_handler.handleOperator(t.image); } (W())*
    ShiftExpression()
  )*
}

void ShiftExpression() :
{
    Token t;
}
{
  AdditiveExpression()
  (
    ( t="<<" | t=">>" |
      t=">>>" )                { m_handler.handleOperator(t.image); } (W())*
    AdditiveExpression()
  )*
}

void AdditiveExpression() :
{
    Token t;
}
{
  MultiplicativeExpression()
  (
    ( t="+" | t="-" )          { m_handler.handleOperator(t.image); } (W())*
    MultiplicativeExpression()
  )*
}

void MultiplicativeExpression() :
{
    Token t;
}
{
  UnaryExpression()
  (
    ( t="*" | t="/" | t="%" )  { m_handler.handleOperator(t.image); } (W())*
    UnaryExpression()
  )*
}

void UnaryExpression() :
{
    Token t;
}
{
  ( t="+" | t="-" )             { m_handler.handleOperator(t.image); } (W())*
  UnaryExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression() :
{
    Token t;
}
{
  t="++"                        { m_handler.handleOperator(t.image); } (W())*
  PrimaryExpression()
}

void PreDecrementExpression() :
{
    Token t;
}
{
  t="--"                        { m_handler.handleOperator(t.image); } (W())*
  PrimaryExpression()
}

void UnaryExpressionNotPlusMinus() :
{
    Token t;
}
{
  ( t="~" | t="!" )             { m_handler.handleOperator(t.image); } (W())*
  UnaryExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression() 
|
  PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD
// specifications below are not used, but they are there just to
// indicate that we know about this.
void CastLookahead() :
{
    Token t;
}
{
  LOOKAHEAD("(" (W())* PrimitiveType())
  "("  (W())* PrimitiveType()
|
  LOOKAHEAD("(" (W())* Type() "[")
  "(" (W())* Type() "[" (W())* "]"
|
  "(" (W())* Type() ")" (W())*
  ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

void PostfixExpression() :
{
    Token t;
}
{
  PrimaryExpression()
  [
    (t="++" | t="--")   { m_handler.handleOperator(t.image); } (W())*
  ]
}

void CastExpression() :
{
    Token t;
}
{
    LOOKAHEAD("(" (W())* PrimitiveType())
    t="("               { m_handler.handleOperator(t.image); } (W())*
    Type()
    t=")"               { m_handler.handleOperator(t.image); } (W())*
    UnaryExpression()
  |
    t="("               { m_handler.handleOperator(t.image); } (W())*
    Type()
    t=")"               { m_handler.handleOperator(t.image); } (W())*
    UnaryExpressionNotPlusMinus()
}

void PrimaryExpression() :
{
    Token t;
}
{
    PrimaryPrefix()
    ( LOOKAHEAD(10)
      PrimarySuffix()
    )*
}

void PrimaryPrefix() :
{
    Token t;
}
{
  Literal()
|
  t="this"                      { m_handler.handleKeyword(t.image);  } (W())*
|
  t="super"                     { m_handler.handleKeyword(t.image);  } (W())*
  t="."                         { m_handler.handleOperator(t.image); } (W())*
  t=<IDENTIFIER>                { m_handler.handleLiteral(t.image);  } (W())*
|
  t="("                         { m_handler.handleOperator(t.image); } (W())*
  Expression()
  t=")"                         { m_handler.handleOperator(t.image); } (W())*
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() "." (W())* "class" (W())*)
  ResultType()
  t="."                         { m_handler.handleOperator(t.image); } (W())*
  t="class"                     { m_handler.handleKeyword(t.image);  } (W())*
|
  Name()
}

void PrimarySuffix() :
{
    Token t;
}
{
  LOOKAHEAD("." (W())* <THIS>)
  t="."                         { m_handler.handleOperator(t.image); } (W())*
  t=<THIS>                      { m_handler.handleKeyword(t.image);  } (W())*
|
  LOOKAHEAD("." (W())* AllocationExpression())
  t="."                         { m_handler.handleOperator(t.image); } (W())*
  AllocationExpression()
|
  t="["                         { m_handler.handleOperator(t.image); } (W())*
  Expression()
  t="]"                         { m_handler.handleOperator(t.image); } (W())*
|
  t="."                         { m_handler.handleOperator(t.image); } (W())*
  t=<IDENTIFIER>                { m_handler.handleLiteral(t.image);  } (W())*
|
  Arguments()
}

void Literal() :
{
    Token t;
}
{
  t=<INTEGER_LITERAL>           { m_handler.handleLiteral(t.image); } (W())*
|
  t=<FLOATING_POINT_LITERAL>    { m_handler.handleLiteral(t.image); } (W())*
|
  t=<CHARACTER_LITERAL>         { m_handler.handleLiteral(t.image); } (W())*
|
  t=<STRING_LITERAL>            { m_handler.handleString(t.image); }  (W())*
|
  BooleanLiteral()
|
  NullLiteral()
}

void BooleanLiteral() :
{
    Token t;
}
{
  t=<TRUE>                      { m_handler.handleKeyword(t.image); } (W())*
|
  t=<FALSE>                     { m_handler.handleKeyword(t.image); } (W())*
}

void NullLiteral() :
{
    Token t;
}
{
  t=<NULL>                      { m_handler.handleKeyword(t.image); } (W())*
}

void Arguments() :
{
    Token t;
}
{
  t="("                        { m_handler.handleOperator(t.image); } (W())*
    [ ArgumentList() ]
  t=")"                        { m_handler.handleOperator(t.image); } (W())*
}

void ArgumentList() :
{
    Token t;
}
{
    Expression()
    (
      t=","                    { m_handler.handleOperator(t.image); } (W())*
      Expression()
    )*
}

void AllocationExpression() :
{
    Token t;
}
{
  LOOKAHEAD(<NEW> (W())* PrimitiveType())
  t="new"                      { m_handler.handleKeyword(t.image); } (W())*
  PrimitiveType()
  ArrayDimsAndInits()
|
  t="new"                      { m_handler.handleKeyword(t.image); } (W())*
  Name()
    (
      ArrayDimsAndInits()
    |
      Arguments() [ ClassBody() ]
    )
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{
    Token t;
}
{
  LOOKAHEAD(3)
  ( LOOKAHEAD("[" (W())* Expression())
  t="["                        { m_handler.handleOperator(t.image); } (W())*
  Expression()
  t="]"                        { m_handler.handleOperator(t.image); } (W())*
  )+
  ( LOOKAHEAD("[" (W())* "]")
  t="["                        { m_handler.handleOperator(t.image); } (W())*
  t="]"                        { m_handler.handleOperator(t.image); } (W())*
  )*
|
  (
    t="["                      { m_handler.handleOperator(t.image); } (W())*
    t="]"                      { m_handler.handleOperator(t.image); } (W())*
  )+
  ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement() :
{
    Token t;
}
{
  LOOKAHEAD( <IDENTIFIER> (W())* ":" )
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression()
   t=";"                    { m_handler.handleOperator(t.image); } (W())*
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
}

void LabeledStatement() :
{
    Token t;
}
{
    t=<IDENTIFIER>        { m_handler.handleLiteral(t.image);  } (W())*
    t=":"                 { m_handler.handleOperator(t.image); } (W())*
    Statement()
}

void Block() :
{
    Token t;
}
{
    t="{"                { m_handler.handleOperator(t.image); }
    (LOOKAHEAD(1) W())*
    (
      BlockStatement()
    )*
    (
      <EOF>
      |
      t="}"                { m_handler.handleOperator(t.image); }
      (LOOKAHEAD(1) W())*
    )
}

void BlockStatement() :
{
    Token t;
}
{
    LOOKAHEAD([ <FINAL> (W())*] Type() <IDENTIFIER>)
    LocalVariableDeclaration()
    t=";"                { m_handler.handleOperator(t.image); } (W())*
|
    Statement()
|
    UnmodifiedClassDeclaration()
|
    UnmodifiedInterfaceDeclaration()
}

void LocalVariableDeclaration() :
{
    Token t;
}
{
  [
    t="final"            { m_handler.handleKeyword(t.image);  } (W())*
  ]
  Type() VariableDeclarator()
  (
    t=","                { m_handler.handleOperator(t.image); } (W())*
    VariableDeclarator()
  )*
}

void EmptyStatement() :
{
    Token t;
}
{
    t=";"                 { m_handler.handleOperator(t.image); } (W())*
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
    Token t;
}
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  PrimaryExpression()
  [
    t="++"                      { m_handler.handleOperator(t.image); } (W())*
  |
    t="--"                      { m_handler.handleOperator(t.image); } (W())*
  |
    AssignmentOperator() Expression()
  ]
}

void SwitchStatement() :
{
    Token t;
}
{
  t="switch"                     { m_handler.handleKeyword(t.image);  } (W())*
  t="("                          { m_handler.handleOperator(t.image); } (W())*
  Expression()
  t=")"                          { m_handler.handleOperator(t.image); } (W())*
  t="{"                          { m_handler.handleOperator(t.image); } (W())*
    (
      SwitchLabel()
      ( BlockStatement() )*
    )*
  t="}"                          { m_handler.handleOperator(t.image); } (W())*
}

void SwitchLabel() :
{
    Token t;
}
{
  t="case"                       { m_handler.handleKeyword(t.image);  } (W())*
  Expression()
  t=":"                          { m_handler.handleOperator(t.image); } (W())*
|
  t="default"                    { m_handler.handleKeyword(t.image);  } (W())*
  t=":"                          { m_handler.handleOperator(t.image); } (W())*
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
    Token t;
}
{
    t="if"                       { m_handler.handleKeyword(t.image);  } (W())*
    t="("                        { m_handler.handleOperator(t.image); } (W())*
    Expression()
    t=")"                        { m_handler.handleOperator(t.image); } (W())*
    Statement()
    [ LOOKAHEAD(1)
      t="else"                   { m_handler.handleKeyword(t.image);  } (W())*
      Statement()
    ]
}

void WhileStatement() :
{
    Token t;
}
{
    t="while"                   { m_handler.handleKeyword(t.image); }  (W())*
    t="("                       { m_handler.handleOperator(t.image); } (W())*
    Expression()
    t=")"                       { m_handler.handleOperator(t.image); } (W())*
    Statement()
}

void DoStatement() :
{
    Token t;
}
{
    t="do"                     { m_handler.handleKeyword(t.image); }  (W())*
    Statement()
    (
      <EOF>
      |
      t="while"                { m_handler.handleKeyword(t.image); }  (W())*
      t="("                    { m_handler.handleOperator(t.image); } (W())*
      Expression()
      t=")"                    { m_handler.handleOperator(t.image); } (W())*
      t=";"                    { m_handler.handleOperator(t.image); } (W())*
    )
}

void ForStatement() :
{
    Token t;
}
{
    t="for"                    { m_handler.handleKeyword(t.image); }  (W())*
    t="("                      { m_handler.handleOperator(t.image); } (W())*
    (
        LOOKAHEAD( Type() (W())* <IDENTIFIER> (W())* ":")
        Type() (W())*
        t=<IDENTIFIER> { m_handler.handleLiteral(t.image); } (W())*
        t=":" { m_handler.handleOperator(t.image); } (W())*
        Expression() (W())*
    |
        [ ForInit() ]
        t=";"                      { m_handler.handleOperator(t.image); } (W())*
        [ Expression() ]
        t=";"                      { m_handler.handleOperator(t.image); } (W())*
        [ ForUpdate() ]
    )
    t=")"                      { m_handler.handleOperator(t.image); } (W())*
    Statement()
}

void ForInit() :
{
}
{
  LOOKAHEAD( ["final" (W())* ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() :
{
    Token t;
}
{
  StatementExpression()
  (
    t=","                   { m_handler.handleOperator(t.image); } (W())*
    StatementExpression()
  )*
}

void ForUpdate() :
{
}
{
  StatementExpressionList()
}

void BreakStatement() :
{
    Token t;
}
{
    t="break"               { m_handler.handleKeyword(t.image); }  (W())*
    [
      t=<IDENTIFIER>        { m_handler.handleLiteral(t.image); }  (W())*
    ]
    t=";"                   { m_handler.handleOperator(t.image); } (W())*
}

void ContinueStatement() :
{
    Token t;
}
{
    t="continue"            { m_handler.handleKeyword(t.image); }  (W())*
    [
      t=<IDENTIFIER>        { m_handler.handleLiteral(t.image); }  (W())*
    ]
    t=";"                   { m_handler.handleOperator(t.image); } (W())*
}

void ReturnStatement() :
{
    Token t;
}
{
    t="return"              { m_handler.handleKeyword(t.image); }  (W())*
    [ Expression() ]
    t=";"                   { m_handler.handleOperator(t.image); } (W())*
}

void ThrowStatement() :
{
    Token t;
}
{
    t="throw"              { m_handler.handleKeyword(t.image); }  (W())*
    Expression()
    t=";"                  { m_handler.handleOperator(t.image); } (W())*
}

void SynchronizedStatement() :
{
    Token t;
}
{
    t="synchronized"       { m_handler.handleKeyword(t.image); }  (W())*
    t="("                  { m_handler.handleOperator(t.image); } (W())*
    Expression()
    t=")"                  { m_handler.handleOperator(t.image); } (W())*
    Block()
}

void TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
    Token t;
}
{
    t="try"                { m_handler.handleKeyword(t.image);  } (W())*
    Block()
    (
      t="catch"            { m_handler.handleKeyword(t.image);  } (W())*
      t="("                { m_handler.handleOperator(t.image); } (W())*
      FormalParameter()
      t=")"                { m_handler.handleOperator(t.image); } (W())*
      Block()
    )*
    [
      t="finally"          { m_handler.handleKeyword(t.image);  } (W())*
      Block()
    ]
}
