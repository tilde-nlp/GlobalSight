/**
 *  Copyright 2009 Welocalize, Inc. 
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  
 *  You may obtain a copy of the License at 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */
package com.globalsight.ling.tw;

import com.globalsight.ling.tw.internal.InternalTextUtil;

/**
 * Pseudo tag parser.
 */
public class PseudoParser
{
    private static String TWO_LEFT_BRACKETS = " gs_TWO_LEFT_BRACKETS ";
    private static String ONE_RIGHT_BRACKET = " gs_ONE_RIGHT_BRACKET ";
    PseudoBaseHandler eventHandler;

    /**
     * Constructor.
     * 
     * @param handler
     *            - An external event handler class which will capture and
     *            process token events generated by the tokenizer.
     */
    public PseudoParser(PseudoBaseHandler handler)
    {
        eventHandler = handler;
    }

    /*
     * An internal handler which captures a tag event, performs neccessary
     * pre-processing steps, and then passes the tag to the external tag event
     * handler.
     * 
     * @param p_strTagContent java.lang.String
     */
    private void processTag(String tagContent) throws PseudoParserException
    {
        eventHandler.processTag(tagContent, PseudoConstants.PSEUDO_OPEN_TAG
                + tagContent + PseudoConstants.PSEUDO_CLOSE_TAG);
    }

    /*
     * An internal handler which captures a text event, performs neccessary
     * pre-processing steps, and then passes the text to the external text event
     * handler.
     * 
     * @param p_strTagContent java.lang.String
     */
    private void processText(String p_strText)
    {
        eventHandler.processText(p_strText);
    }

    /**
     * P-Tag Tokenizer.
     * <p>
     * 
     * Tokenizes the input string and calls the processText and processTag
     * methods. The tokenizer recognizes anything that uses legal P-Tag syntax,
     * even if it happens to be source text. Higher levels of error checking
     * will catch cases where the user needs to escape source text that looks
     * like a P-tag.
     * <p>
     * 
     * User defined open brackets must be escaped with an additional open
     * bracket.
     * <p>
     * 
     * Example:
     * <p>
     * <p>
     * "Globalsight P-tags look like this [tag_name]" // incorrect
     * <p>
     * "Globalsight P-tags look like this [[tag_name]" // Correct
     * <p>
     * <p>
     * 
     * An escape encoder/decoder will handle the insertion and removal of the
     * escape bracket for existing text. If the user wants to insert new open
     * brackets in the text, they must use the double open bracket.
     * <p>
     * 
     * However, the requirements for escaping literal braces are forgiving. If
     * the user enters a single open bracket preceding a P-tag and does not
     * escape it, the tokenizer is smart enough to know that an open bracket
     * cannot exists within a P-Tag and assumes the previous open bracket (the
     * one the user entered) was text. If the user's new open bracket does not
     * precede any P-tags, and the end of line is reached, an end-of-tag will be
     * assumed and the sub-string will be recognized as a tag. This action
     * allows the error checker class to catch errors where the closing brace on
     * the last P-tag was accidentally deleted.
     * <p>
     * 
     * The times when a user MUST escape an OPEN bracket is when there is also a
     * user defined CLOSE brace BEFORE the next P-tag or it is not followed by
     * any other P-tags before reaching the end-of-line.
     * <p>
     */
    public void tokenize(String pseudoString) throws PseudoParserException
    {
        boolean bInTag = false;
        StringBuffer strCurrentText = new StringBuffer(128);
        String newPseudoString = pseudoString;
        boolean hasSpecialChar = false;

        if (newPseudoString.contains("[[[") && newPseudoString.contains("]]"))
        {
            hasSpecialChar = true;
            newPseudoString = handleSpecialChar(newPseudoString);
        }

        for (int i = 0; i < newPseudoString.length(); i++)
        {
            char c = newPseudoString.charAt(i);

            if ((c == PseudoConstants.PSEUDO_OPEN_TAG))
            {
                // check for escape
                char nextc = (i == newPseudoString.length() - 1) ? ' '
                        : newPseudoString.charAt(i + 1); // avoid end of line

                if (nextc == PseudoConstants.PSEUDO_OPEN_TAG)
                {
                    strCurrentText.append(c);
                    strCurrentText.append(nextc);
                    i++;
                }
                else
                {
                    if (bInTag)
                    {
                        // a open bracket cannot exist inside a tag -
                        // must be text
                        strCurrentText.insert(0,
                                PseudoConstants.PSEUDO_OPEN_TAG);
                    }

                    // process any text that came before the tag
                    String temp = strCurrentText.toString();
                    if (hasSpecialChar)
                    {
                        temp = temp.replace(TWO_LEFT_BRACKETS, "[[");
                        temp = temp.replace(ONE_RIGHT_BRACKET, "]");
                    }
                    processText(temp);
                    strCurrentText.setLength(0);
                    bInTag = true;
                }
            }
            else if (c == PseudoConstants.PSEUDO_CLOSE_TAG)
            {
                if (bInTag)
                {
                    String temp = strCurrentText.toString();
                    if (hasSpecialChar)
                    {
                        temp = temp.replace(TWO_LEFT_BRACKETS, "[[");
                        temp = temp.replace(ONE_RIGHT_BRACKET, "]");
                    }
                    // for GBS-2580, replace [] back before displaying to user
                    temp = temp
                            .replace(
                                    InternalTextUtil.INSIDE_INTERNAL_BRACKET_LEFT,
                                    "[")
                            .replace(
                                    InternalTextUtil.INSIDE_INTERNAL_BRACKET_RIGHT,
                                    "]");
                    processTag(temp);
                    strCurrentText.setLength(0);
                    bInTag = false;
                }
                else
                {
                    strCurrentText.append(c);
                }
            }
            else
            {
                strCurrentText.append(c);
            }
        }

        if (strCurrentText.length() > 0)
        {
            String temp = strCurrentText.toString();
            if (hasSpecialChar)
            {
                temp = temp.replace(TWO_LEFT_BRACKETS, "[[");
                temp = temp.replace(ONE_RIGHT_BRACKET, "]");
            }

            if (bInTag)
            {
                processTag(temp);
                strCurrentText.setLength(0);
                bInTag = false;
            }

            processText(temp);
        }
    }

    private String handleSpecialChar(String p_segmentString)
    {
        int len = p_segmentString.length();
        StringBuffer result = new StringBuffer(len);
        StringBuffer temp = new StringBuffer();
        ;
        boolean leftOccur = false;

        for (int i = 0; i < len; i++)
        {
            char c = p_segmentString.charAt(i);

            if (c == '[')
            {
                leftOccur = true;
                temp.append(c);
            }
            else if (c == ']')
            {
                temp.append(c);

                if (i + 1 < len)
                {
                    char nextc = p_segmentString.charAt(i + 1);
                    if (nextc == ']')
                    {
                        continue;
                    }
                }

                // if not continue
                leftOccur = false;
                String tempstr = temp.toString();
                // just handle [[[internal text]]
                if (tempstr.startsWith("[[[") && tempstr.endsWith("]]")
                        && !tempstr.startsWith("[[[[")
                        && !tempstr.endsWith("]]]"))
                {
                    tempstr = tempstr.replace("[[[", "[" + TWO_LEFT_BRACKETS);
                    tempstr = tempstr.replace("]]", ONE_RIGHT_BRACKET + "]");
                }
                result.append(tempstr);
                temp.setLength(0);
            }
            else if (leftOccur)
            {
                temp.append(c);
            }
            else
            {
                result.append(c);
            }
        }

        if (temp.length() != 0)
        {
            result.append(temp.toString());
        }

        String resultstr = result.toString();
        resultstr = resultstr.replace("[[", TWO_LEFT_BRACKETS);

        return resultstr;
    }
}
